# 文件名稱搜尋功能 - 簡化方案

## 1. 需求概述

### 1.1 核心需求
- 📄 搜尋文章中上傳的文件（按文件名）
- 🔍 支持模糊搜尋（不需要完整文件名）
- 🎯 簡單、快速、易實現

### 1.2 使用場景
- 用戶記得文件名的一部分，想找到相關文章
- 搜尋「報告」能找到「2024年度報告.pdf」
- 搜尋「圖片」能找到「旅遊圖片合集.zip」

---

## 2. 簡化的數據模型設計

### 2.1 最小化方案（推薦）⭐⭐⭐⭐⭐

由於只需搜尋文件名，我們可以用最簡單的方式：

```prisma
// 媒體附件模型
model Attachment {
  id           String   @id @default(uuid())
  filename     String   // 文件名（可搜尋）
  originalName String   // 原始文件名（用戶上傳時的名稱）
  url          String   // 文件 URL
  mimeType     String   // 文件類型（image/jpeg, application/pdf）
  size         Int      // 文件大小（bytes）
  
  postId       String
  uploaderId   String
  createdAt    DateTime @default(now())
  
  // 關聯
  post         Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  uploader     User     @relation(fields: [uploaderId], references: [id], onDelete: Cascade)
  
  @@index([filename])      // 文件名搜尋索引
  @@index([originalName])  // 原始文件名搜尋索引
  @@index([postId])
  @@map("attachments")
}

// 更新 Post 模型
model Post {
  // ... 現有欄位 ...
  
  attachments  Attachment[]  // 一篇文章可以有多個附件
  
  @@map("posts")
}

// 更新 User 模型
model User {
  // ... 現有欄位 ...
  
  attachments  Attachment[]  // 用戶上傳的附件
  
  @@map("users")
}
```

**優點：**
- ✅ 極其簡單，只關注文件名搜尋
- ✅ 開發快速（1-2 天完成）
- ✅ 查詢性能好
- ✅ 維護容易

---

## 3. 模糊搜尋實現方案

### 3.1 方案 A：PostgreSQL ILIKE（推薦）⭐⭐⭐⭐⭐

**特點：**
- 最簡單的模糊搜尋
- 支持部分匹配
- 大小寫不敏感

**實現：**
```typescript
// backend/src/search/search.service.ts

async searchAttachments(params: {
  query: string;
  page: number;
  limit: number;
}) {
  const { query, page, limit } = params;
  const skip = (page - 1) * limit;

  // 模糊搜尋文件名
  const where = {
    OR: [
      { filename: { contains: query, mode: 'insensitive' } },
      { originalName: { contains: query, mode: 'insensitive' } },
    ],
  };

  const [attachments, total] = await Promise.all([
    this.prisma.attachment.findMany({
      where,
      include: {
        post: {
          select: { id: true, title: true },
        },
        uploader: {
          select: { id: true, username: true, name: true },
        },
      },
      orderBy: { createdAt: 'desc' },
      skip,
      take: limit,
    }),
    this.prisma.attachment.count({ where }),
  ]);

  return {
    success: true,
    message: 'Attachments found',
    data: {
      attachments,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    },
  };
}
```

**搜尋效果示例：**
```
搜尋「報告」可以找到：
- "2024年度報告.pdf"
- "財務報告_Q1.xlsx"
- "項目報告書.docx"

搜尋「2024」可以找到：
- "2024年度報告.pdf"
- "2024_照片.zip"
- "會議記錄_2024.doc"

搜尋「.pdf」可以找到所有 PDF 文件
```

---

### 3.2 方案 B：模糊匹配 + 相似度排序（進階）⭐⭐⭐⭐

如果需要更智能的搜尋（例如容錯拼寫），可以使用 PostgreSQL 的模糊匹配：

```typescript
// 使用 PostgreSQL 的相似度函數
async searchAttachmentsFuzzy(query: string) {
  const results = await this.prisma.$queryRaw`
    SELECT 
      id,
      filename,
      original_name,
      url,
      similarity(filename, ${query}) as similarity_score
    FROM attachments
    WHERE 
      filename ILIKE ${'%' + query + '%'}
      OR original_name ILIKE ${'%' + query + '%'}
      OR similarity(filename, ${query}) > 0.3
    ORDER BY similarity_score DESC
    LIMIT 20
  `;
  
  return results;
}
```

**需要安裝 PostgreSQL 擴展：**
```sql
-- 啟用 pg_trgm 擴展（用於模糊匹配）
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- 創建 GIN 索引（加速模糊搜尋）
CREATE INDEX attachments_filename_trgm_idx ON attachments USING gin(filename gin_trgm_ops);
CREATE INDEX attachments_original_name_trgm_idx ON attachments USING gin(original_name gin_trgm_ops);
```

**效果：**
- 搜尋「報吿」（錯字）也能找到「報告」
- 搜尋「reprot」（拼錯）也能找到「report」

---

## 4. 完整實現代碼

### 4.1 後端實現

#### 4.1.1 SearchController 添加附件搜尋

```typescript
// backend/src/search/search.controller.ts

import { Controller, Get, Query } from '@nestjs/common';
import { SearchService } from './search.service';

@Controller('search')
export class SearchController {
  constructor(private readonly searchService: SearchService) {}

  /**
   * 搜尋附件（按文件名）
   */
  @Get('attachments')
  async searchAttachments(
    @Query('q') query: string,
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    if (!query) {
      return {
        success: false,
        message: 'Query parameter is required',
      };
    }

    return this.searchService.searchAttachments({
      query,
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }

  /**
   * 搜尋包含附件的文章
   */
  @Get('posts/with-attachments')
  async searchPostsWithAttachments(
    @Query('q') query: string,
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    if (!query) {
      return {
        success: false,
        message: 'Query parameter is required',
      };
    }

    return this.searchService.searchPostsWithAttachments({
      query,
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }
}
```

#### 4.1.2 SearchService 實現

```typescript
// backend/src/search/search.service.ts

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class SearchService {
  constructor(private prisma: PrismaService) {}

  /**
   * 搜尋附件（按文件名）
   */
  async searchAttachments(params: {
    query: string;
    page: number;
    limit: number;
  }) {
    const { query, page, limit } = params;
    const skip = (page - 1) * limit;

    // 模糊搜尋文件名
    const where = {
      OR: [
        { filename: { contains: query, mode: 'insensitive' as const } },
        { originalName: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    const [attachments, total] = await Promise.all([
      this.prisma.attachment.findMany({
        where,
        include: {
          post: {
            select: {
              id: true,
              title: true,
              createdAt: true,
            },
          },
          uploader: {
            select: {
              id: true,
              username: true,
              name: true,
              avatar: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit,
      }),
      this.prisma.attachment.count({ where }),
    ]);

    return {
      success: true,
      message: `Found ${total} attachment(s)`,
      data: {
        attachments,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasMore: page * limit < total,
        },
      },
    };
  }

  /**
   * 搜尋包含特定附件的文章
   */
  async searchPostsWithAttachments(params: {
    query: string;
    page: number;
    limit: number;
  }) {
    const { query, page, limit } = params;
    const skip = (page - 1) * limit;

    const where = {
      isPublished: true,
      attachments: {
        some: {
          OR: [
            { filename: { contains: query, mode: 'insensitive' as const } },
            { originalName: { contains: query, mode: 'insensitive' as const } },
          ],
        },
      },
    };

    const [posts, total] = await Promise.all([
      this.prisma.post.findMany({
        where,
        include: {
          author: {
            select: {
              id: true,
              username: true,
              name: true,
              avatar: true,
            },
          },
          attachments: {
            where: {
              OR: [
                { filename: { contains: query, mode: 'insensitive' as const } },
                { originalName: { contains: query, mode: 'insensitive' as const } },
              ],
            },
          },
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit,
      }),
      this.prisma.post.count({ where }),
    ]);

    return {
      success: true,
      message: `Found ${total} post(s) with matching attachments`,
      data: {
        posts,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasMore: page * limit < total,
        },
      },
    };
  }
}
```

---

### 4.2 前端實現

#### 4.2.1 搜尋服務

```typescript
// frontend/src/services/search.service.ts

import { apiClient } from './api.client';

export interface Attachment {
  id: string;
  filename: string;
  originalName: string;
  url: string;
  mimeType: string;
  size: number;
  createdAt: string;
  post: {
    id: string;
    title: string;
  };
  uploader: {
    id: string;
    username: string;
    name: string;
  };
}

export const searchService = {
  /**
   * 搜尋附件（按文件名）
   */
  async searchAttachments(params: {
    query: string;
    page?: number;
    limit?: number;
  }) {
    const response = await apiClient.get('/search/attachments', { params });
    return {
      attachments: response.data.attachments as Attachment[],
      pagination: response.data.pagination,
    };
  },

  /**
   * 搜尋包含附件的文章
   */
  async searchPostsWithAttachments(params: {
    query: string;
    page?: number;
    limit?: number;
  }) {
    const response = await apiClient.get('/search/posts/with-attachments', { params });
    return {
      posts: response.data.posts,
      pagination: response.data.pagination,
    };
  },
};
```

#### 4.2.2 搜尋頁面 UI

```typescript
// frontend/src/screens/SearchScreen.tsx

import React, { useState } from 'react';
import { View, FlatList, StyleSheet } from 'react-native';
import { Searchbar, Card, Text, Chip, Avatar, IconButton } from 'react-native-paper';
import { searchService, Attachment } from '../services/search.service';

export default function SearchScreen() {
  const [query, setQuery] = useState('');
  const [searchType, setSearchType] = useState<'attachments' | 'posts'>('attachments');
  const [results, setResults] = useState<Attachment[]>([]);
  const [loading, setLoading] = useState(false);

  const handleSearch = async () => {
    if (!query.trim()) return;
    
    setLoading(true);
    try {
      if (searchType === 'attachments') {
        const data = await searchService.searchAttachments({ query });
        setResults(data.attachments);
      } else {
        const data = await searchService.searchPostsWithAttachments({ query });
        setResults(data.posts);
      }
    } catch (error) {
      console.error('Search error:', error);
    } finally {
      setLoading(false);
    }
  };

  const formatFileSize = (bytes: number) => {
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  };

  const getFileIcon = (mimeType: string) => {
    if (mimeType.startsWith('image/')) return 'image';
    if (mimeType.startsWith('video/')) return 'video';
    if (mimeType.includes('pdf')) return 'file-pdf';
    if (mimeType.includes('word')) return 'file-word';
    if (mimeType.includes('excel') || mimeType.includes('spreadsheet')) return 'file-excel';
    return 'file';
  };

  const renderAttachment = ({ item }: { item: Attachment }) => (
    <Card style={styles.card}>
      <Card.Content>
        <View style={styles.row}>
          <Avatar.Icon 
            size={48} 
            icon={getFileIcon(item.mimeType)} 
            style={styles.icon}
          />
          <View style={styles.info}>
            <Text variant="titleMedium" numberOfLines={1}>
              {item.originalName}
            </Text>
            <Text variant="bodySmall" style={styles.subtitle}>
              {formatFileSize(item.size)} • {item.post.title}
            </Text>
            <View style={styles.meta}>
              <Chip icon="account" compact>
                {item.uploader.name || item.uploader.username}
              </Chip>
            </View>
          </View>
          <IconButton
            icon="download"
            onPress={() => {
              // 下載或打開文件
              console.log('Download:', item.url);
            }}
          />
        </View>
      </Card.Content>
    </Card>
  );

  return (
    <View style={styles.container}>
      <Searchbar
        placeholder="搜尋文件名稱..."
        value={query}
        onChangeText={setQuery}
        onSubmitEditing={handleSearch}
        icon="file-search"
      />

      <View style={styles.filters}>
        <Chip
          selected={searchType === 'attachments'}
          onPress={() => setSearchType('attachments')}
          style={styles.chip}
        >
          搜尋文件
        </Chip>
        <Chip
          selected={searchType === 'posts'}
          onPress={() => setSearchType('posts')}
          style={styles.chip}
        >
          搜尋文章
        </Chip>
      </View>

      <FlatList
        data={results}
        renderItem={renderAttachment}
        keyExtractor={(item) => item.id}
        refreshing={loading}
        onRefresh={handleSearch}
        ListEmptyComponent={
          <View style={styles.empty}>
            <Text>
              {query ? '沒有找到相關文件' : '輸入文件名稱開始搜尋'}
            </Text>
          </View>
        }
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  filters: {
    flexDirection: 'row',
    marginVertical: 12,
    gap: 8,
  },
  chip: {
    marginRight: 8,
  },
  card: {
    marginBottom: 12,
  },
  row: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  icon: {
    marginRight: 12,
  },
  info: {
    flex: 1,
  },
  subtitle: {
    opacity: 0.7,
    marginTop: 4,
  },
  meta: {
    flexDirection: 'row',
    marginTop: 8,
  },
  empty: {
    padding: 32,
    alignItems: 'center',
  },
});
```

---

## 5. 數據庫遷移

### 5.1 創建 Attachment 表

```bash
# 創建新的遷移
npx prisma migrate dev --name add_attachments
```

### 5.2 遷移腳本（如果需要遷移現有圖片）

```typescript
// prisma/migrate-images-to-attachments.ts

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function migrateImagesToAttachments() {
  console.log('Starting migration...');

  // 獲取所有有圖片的文章
  const postsWithImages = await prisma.post.findMany({
    where: {
      image: { not: null },
    },
  });

  console.log(`Found ${postsWithImages.length} posts with images`);

  for (const post of postsWithImages) {
    // 從 URL 提取文件名
    const filename = post.image!.split('/').pop() || 'image.jpg';
    
    // 創建附件記錄
    await prisma.attachment.create({
      data: {
        filename,
        originalName: filename,
        url: post.image!,
        mimeType: 'image/jpeg', // 假設是 JPEG
        size: 0, // 未知大小
        postId: post.id,
        uploaderId: post.authorId,
      },
    });

    console.log(`Migrated image for post: ${post.id}`);
  }

  console.log('Migration completed!');
}

migrateImagesToAttachments()
  .catch(console.error)
  .finally(() => prisma.$disconnect());
```

---

## 6. 實施計劃

### 6.1 開發步驟

**階段 1：數據模型（0.5 天）**
- [ ] 添加 Attachment 模型到 Prisma schema
- [ ] 執行數據庫遷移
- [ ] 添加索引

**階段 2：後端 API（1 天）**
- [ ] 實現附件搜尋 API
- [ ] 實現文章附件搜尋 API
- [ ] 添加 API 測試

**階段 3：前端實現（1 天）**
- [ ] 創建搜尋服務
- [ ] 實現搜尋頁面 UI
- [ ] 添加文件預覽功能

**階段 4：測試和優化（0.5 天）**
- [ ] 測試模糊搜尋效果
- [ ] 性能測試
- [ ] 用戶體驗優化

**總時間：3 天** ✅

---

## 7. API 測試示例

### 7.1 測試配置

```typescript
// testing-tools/src/tests/search-attachments.test.ts

export const searchAttachmentsTests = [
  {
    name: 'Search attachments - exact match',
    endpoint: '/search/attachments',
    method: 'GET',
    params: {
      q: '報告.pdf',
      page: 1,
      limit: 10,
    },
    expectedStatus: 200,
  },
  {
    name: 'Search attachments - partial match',
    endpoint: '/search/attachments',
    method: 'GET',
    params: {
      q: '報告',
      page: 1,
      limit: 10,
    },
    expectedStatus: 200,
  },
  {
    name: 'Search posts with attachments',
    endpoint: '/search/posts/with-attachments',
    method: 'GET',
    params: {
      q: '2024',
      page: 1,
      limit: 10,
    },
    expectedStatus: 200,
  },
];
```

### 7.2 使用 curl 測試

```bash
# 搜尋附件
curl "http://localhost:5000/api/search/attachments?q=報告"

# 搜尋包含附件的文章
curl "http://localhost:5000/api/search/posts/with-attachments?q=2024"

# 分頁搜尋
curl "http://localhost:5000/api/search/attachments?q=pdf&page=2&limit=5"
```

---

## 8. 性能優化

### 8.1 數據庫索引

```sql
-- 基礎索引（自動創建）
CREATE INDEX idx_attachments_filename ON attachments(filename);
CREATE INDEX idx_attachments_original_name ON attachments(original_name);
CREATE INDEX idx_attachments_post_id ON attachments(post_id);

-- 如果需要更快的模糊搜尋（可選）
CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE INDEX idx_attachments_filename_trgm ON attachments USING gin(filename gin_trgm_ops);
```

### 8.2 查詢優化建議

```typescript
// 只返回需要的欄位
const attachments = await prisma.attachment.findMany({
  where,
  select: {
    id: true,
    filename: true,
    originalName: true,
    url: true,
    size: true,
    post: {
      select: { id: true, title: true },  // 只選擇需要的欄位
    },
  },
});
```

---

## 9. 搜尋建議優化（可選）

### 9.1 搜尋歷史

```typescript
// 保存搜尋歷史（前端 LocalStorage）
const searchHistory = {
  save: (query: string) => {
    const history = JSON.parse(localStorage.getItem('searchHistory') || '[]');
    if (!history.includes(query)) {
      history.unshift(query);
      localStorage.setItem('searchHistory', JSON.stringify(history.slice(0, 10)));
    }
  },
  
  get: () => {
    return JSON.parse(localStorage.getItem('searchHistory') || '[]');
  },
};
```

### 9.2 自動完成建議

```typescript
// 根據用戶輸入提供建議
async getSearchSuggestions(query: string) {
  if (query.length < 2) return [];
  
  const suggestions = await prisma.attachment.findMany({
    where: {
      originalName: { contains: query, mode: 'insensitive' },
    },
    select: { originalName: true },
    distinct: ['originalName'],
    take: 5,
  });
  
  return suggestions.map(s => s.originalName);
}
```

---

## 10. 總結

### 10.1 優點

✅ **極其簡單**
- 只需要一個 Attachment 表
- 使用基礎的 ILIKE 模糊搜尋
- 無需複雜的分詞或全文搜尋

✅ **開發快速**
- 總開發時間：3 天
- 立即可用，無需等待

✅ **性能良好**
- 有索引支持
- 查詢速度快
- 適合中小型數據量

✅ **維護容易**
- 代碼簡單直觀
- 無需額外服務
- 易於調試

### 10.2 限制

⚠️ **功能簡單**
- 只能搜尋文件名
- 不支持內容搜尋
- 沒有智能排序

⚠️ **適用範圍**
- 適合文件數量 < 10萬
- 適合簡單場景

### 10.3 建議

**適合立即實施：**
- ✅ 需求簡單明確（只搜尋文件名）
- ✅ 開發時間短（3 天）
- ✅ 無需額外成本
- ✅ 可以快速上線驗證需求

**實施順序建議：**
1. 先實現基礎文字搜尋（文章、用戶）← 優先
2. 再實現文件名搜尋 ← 次要
3. 根據需求決定是否需要更複雜的多媒體功能

---

**文檔版本：** v1.0  
**創建日期：** 2025-10-29  
**作者：** HAPPY SHARE 開發團隊  
**狀態：** ✅ 推薦實施 - 簡單實用
**預計時間：** 3 天
