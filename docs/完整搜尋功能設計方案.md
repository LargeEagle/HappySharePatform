# HAPPY SHARE 完整搜尋功能設計方案

## 1. 功能概述

### 1.1 搜尋範圍
- 📝 **文章搜尋**：標題、內容
- 👤 **用戶搜尋**：用戶名、顯示名稱、個人簡介
- 📄 **檔案搜尋**：文件名稱（模糊匹配）
- 🏷️ **Hashtag 搜尋**：標籤名稱、相關文章

### 1.2 核心特點
- ⚡ 統一搜尋界面
- 🔍 模糊搜尋支持
- 🎯 分類篩選
- 📊 搜尋結果排序
- 💾 搜尋歷史

---

## 2. 數據模型設計

### 2.1 完整 Prisma Schema

```prisma
// ===== 現有模型（需要擴展）=====

model User {
  id              String    @id @default(uuid())
  username        String    @unique
  email           String    @unique
  password        String
  name            String?
  bio             String?   @db.Text
  avatar          String?
  location        String?
  website         String?
  postsCount      Int       @default(0)
  followersCount  Int       @default(0)
  followingCount  Int       @default(0)
  totalLikes      Int       @default(0)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // 關聯
  posts           Post[]
  comments        Comment[]
  likes           Like[]
  bookmarks       Bookmark[]
  attachments     Attachment[]  // 新增
  
  @@index([username])   // 搜尋索引
  @@index([name])       // 搜尋索引
  @@map("users")
}

model Post {
  id              String    @id @default(uuid())
  title           String
  content         String    @db.Text
  image           String?
  isPublished     Boolean   @default(true)
  likesCount      Int       @default(0)
  commentsCount   Int       @default(0)
  bookmarksCount  Int       @default(0)
  authorId        String
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // 關聯
  author          User         @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments        Comment[]
  likes           Like[]
  bookmarks       Bookmark[]
  attachments     Attachment[] // 新增
  postTags        PostTag[]    // 新增：文章標籤關聯
  
  @@index([authorId])
  @@index([createdAt])
  @@index([isPublished])
  @@index([title])          // 新增：標題搜尋索引
  @@index([isPublished, likesCount])  // 新增：熱門排序索引
  @@map("posts")
}

// ===== 新增模型 =====

// 附件模型（文件搜尋）
model Attachment {
  id           String   @id @default(uuid())
  filename     String   // 系統生成的文件名
  originalName String   // 原始文件名（用戶上傳時的名稱）
  url          String   // 文件 URL
  mimeType     String   // 文件類型
  size         Int      // 文件大小（bytes）
  
  postId       String
  uploaderId   String
  createdAt    DateTime @default(now())
  
  // 關聯
  post         Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  uploader     User     @relation(fields: [uploaderId], references: [id], onDelete: Cascade)
  
  @@index([filename])      // 文件名搜尋索引
  @@index([originalName])  // 原始名稱搜尋索引
  @@index([postId])
  @@map("attachments")
}

// Hashtag 標籤模型
model Tag {
  id          String    @id @default(uuid())
  name        String    @unique  // 標籤名稱（如：旅遊、美食）
  slug        String    @unique  // URL 友好的標籤（如：travel、food）
  description String?   @db.Text // 標籤描述
  postsCount  Int       @default(0)  // 使用此標籤的文章數
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // 關聯
  postTags    PostTag[]
  
  @@index([name])       // 標籤名稱搜尋索引
  @@index([slug])       // URL slug 索引
  @@index([postsCount]) // 熱門標籤排序索引
  @@map("tags")
}

// 文章-標籤 關聯表（多對多）
model PostTag {
  id        String   @id @default(uuid())
  postId    String
  tagId     String
  createdAt DateTime @default(now())
  
  // 關聯
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  @@unique([postId, tagId])  // 確保同一文章不會重複添加相同標籤
  @@index([postId])
  @@index([tagId])
  @@map("post_tags")
}

// 搜尋歷史模型（可選）
model SearchHistory {
  id        String   @id @default(uuid())
  userId    String?  // null 表示未登入用戶
  query     String   // 搜尋關鍵字
  type      String   // 搜尋類型：all, posts, users, files, tags
  createdAt DateTime @default(now())
  
  @@index([userId])
  @@index([createdAt])
  @@map("search_history")
}
```

---

## 3. API 設計

### 3.1 統一搜尋 API

#### 路由結構
```
GET  /api/search                          # 綜合搜尋（所有類型）
GET  /api/search/posts                    # 搜尋文章
GET  /api/search/users                    # 搜尋用戶
GET  /api/search/files                    # 搜尋文件
GET  /api/search/tags                     # 搜尋標籤
GET  /api/search/suggestions              # 搜尋建議（自動完成）
GET  /api/search/history                  # 搜尋歷史

# Hashtag 相關
GET  /api/tags                            # 獲取所有標籤
GET  /api/tags/popular                    # 熱門標籤
GET  /api/tags/:slug                      # 獲取標籤詳情
GET  /api/tags/:slug/posts                # 獲取標籤下的文章
POST /api/posts/:id/tags                  # 為文章添加標籤
DELETE /api/posts/:id/tags/:tagId         # 移除文章標籤
```

#### 查詢參數
```typescript
interface SearchParams {
  q: string;              // 搜尋關鍵字（必填）
  type?: 'all' | 'posts' | 'users' | 'files' | 'tags';  // 搜尋類型
  sort?: 'relevant' | 'latest' | 'popular';  // 排序方式
  page?: number;          // 頁碼（默認 1）
  limit?: number;         // 每頁數量（默認 10）
}
```

---

## 4. 後端實現

### 4.1 SearchController

```typescript
// backend/src/search/search.controller.ts

import { Controller, Get, Query, UseGuards, Request } from '@nestjs/common';
import { SearchService } from './search.service';
import { OptionalJwtAuthGuard } from '../auth/optional-jwt-auth.guard';

@Controller('search')
export class SearchController {
  constructor(private readonly searchService: SearchService) {}

  /**
   * 綜合搜尋（所有類型）
   */
  @UseGuards(OptionalJwtAuthGuard)
  @Get()
  async search(
    @Query('q') query: string,
    @Query('type') type?: 'all' | 'posts' | 'users' | 'files' | 'tags',
    @Query('page') page?: string,
    @Query('limit') limit?: string,
    @Request() req?,
  ) {
    if (!query || query.trim().length === 0) {
      return {
        success: false,
        message: 'Search query is required',
      };
    }

    // 記錄搜尋歷史
    if (req.user) {
      await this.searchService.saveSearchHistory(
        req.user.id,
        query,
        type || 'all',
      );
    }

    return this.searchService.search({
      query: query.trim(),
      type: type || 'all',
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }

  /**
   * 搜尋文章
   */
  @Get('posts')
  async searchPosts(
    @Query('q') query: string,
    @Query('sort') sort?: 'relevant' | 'latest' | 'popular',
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    if (!query) {
      return { success: false, message: 'Query is required' };
    }

    return this.searchService.searchPosts({
      query,
      sort: sort || 'relevant',
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }

  /**
   * 搜尋用戶
   */
  @Get('users')
  async searchUsers(
    @Query('q') query: string,
    @Query('sort') sort?: 'relevant' | 'followers' | 'posts',
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    if (!query) {
      return { success: false, message: 'Query is required' };
    }

    return this.searchService.searchUsers({
      query,
      sort: sort || 'relevant',
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }

  /**
   * 搜尋文件
   */
  @Get('files')
  async searchFiles(
    @Query('q') query: string,
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    if (!query) {
      return { success: false, message: 'Query is required' };
    }

    return this.searchService.searchFiles({
      query,
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }

  /**
   * 搜尋標籤
   */
  @Get('tags')
  async searchTags(
    @Query('q') query: string,
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    if (!query) {
      return { success: false, message: 'Query is required' };
    }

    return this.searchService.searchTags({
      query,
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }

  /**
   * 搜尋建議（自動完成）
   */
  @Get('suggestions')
  async getSuggestions(@Query('q') query: string) {
    if (!query || query.length < 2) {
      return { success: true, data: { suggestions: [] } };
    }

    return this.searchService.getSuggestions(query);
  }

  /**
   * 獲取搜尋歷史
   */
  @UseGuards(OptionalJwtAuthGuard)
  @Get('history')
  async getSearchHistory(@Request() req) {
    if (!req.user) {
      return { success: true, data: { history: [] } };
    }

    return this.searchService.getSearchHistory(req.user.id);
  }
}
```

### 4.2 SearchService

```typescript
// backend/src/search/search.service.ts

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class SearchService {
  constructor(private prisma: PrismaService) {}

  /**
   * 綜合搜尋
   */
  async search(params: {
    query: string;
    type: 'all' | 'posts' | 'users' | 'files' | 'tags';
    page: number;
    limit: number;
  }) {
    const { query, type, page, limit } = params;

    if (type === 'posts') {
      return this.searchPosts({ query, page, limit });
    }
    if (type === 'users') {
      return this.searchUsers({ query, page, limit });
    }
    if (type === 'files') {
      return this.searchFiles({ query, page, limit });
    }
    if (type === 'tags') {
      return this.searchTags({ query, page, limit });
    }

    // type === 'all'：返回所有類型的結果（各取前 5 個）
    const [posts, users, files, tags] = await Promise.all([
      this.searchPosts({ query, page: 1, limit: 5 }),
      this.searchUsers({ query, page: 1, limit: 5 }),
      this.searchFiles({ query, page: 1, limit: 5 }),
      this.searchTags({ query, page: 1, limit: 5 }),
    ]);

    return {
      success: true,
      message: 'Search completed',
      data: {
        query,
        posts: posts.data.posts,
        users: users.data.users,
        files: files.data.files,
        tags: tags.data.tags,
      },
    };
  }

  /**
   * 搜尋文章
   */
  async searchPosts(params: {
    query: string;
    sort?: 'relevant' | 'latest' | 'popular';
    page: number;
    limit: number;
  }) {
    const { query, sort = 'relevant', page, limit } = params;
    const skip = (page - 1) * limit;

    const where = {
      isPublished: true,
      OR: [
        { title: { contains: query, mode: 'insensitive' as const } },
        { content: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    // 排序邏輯
    let orderBy: any = { createdAt: 'desc' };
    if (sort === 'popular') {
      orderBy = [
        { likesCount: 'desc' },
        { commentsCount: 'desc' },
        { createdAt: 'desc' },
      ];
    }

    const [posts, total] = await Promise.all([
      this.prisma.post.findMany({
        where,
        include: {
          author: {
            select: {
              id: true,
              username: true,
              name: true,
              avatar: true,
            },
          },
          postTags: {
            include: {
              tag: true,
            },
          },
        },
        orderBy,
        skip,
        take: limit,
      }),
      this.prisma.post.count({ where }),
    ]);

    return {
      success: true,
      message: `Found ${total} post(s)`,
      data: {
        posts,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasMore: page * limit < total,
        },
      },
    };
  }

  /**
   * 搜尋用戶
   */
  async searchUsers(params: {
    query: string;
    sort?: 'relevant' | 'followers' | 'posts';
    page: number;
    limit: number;
  }) {
    const { query, sort = 'relevant', page, limit } = params;
    const skip = (page - 1) * limit;

    const where = {
      OR: [
        { username: { contains: query, mode: 'insensitive' as const } },
        { name: { contains: query, mode: 'insensitive' as const } },
        { bio: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    // 排序邏輯
    let orderBy: any = { followersCount: 'desc' };
    if (sort === 'posts') {
      orderBy = { postsCount: 'desc' };
    }

    const [users, total] = await Promise.all([
      this.prisma.user.findMany({
        where,
        select: {
          id: true,
          username: true,
          name: true,
          bio: true,
          avatar: true,
          location: true,
          followersCount: true,
          followingCount: true,
          postsCount: true,
        },
        orderBy,
        skip,
        take: limit,
      }),
      this.prisma.user.count({ where }),
    ]);

    return {
      success: true,
      message: `Found ${total} user(s)`,
      data: {
        users,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasMore: page * limit < total,
        },
      },
    };
  }

  /**
   * 搜尋文件
   */
  async searchFiles(params: {
    query: string;
    page: number;
    limit: number;
  }) {
    const { query, page, limit } = params;
    const skip = (page - 1) * limit;

    const where = {
      OR: [
        { filename: { contains: query, mode: 'insensitive' as const } },
        { originalName: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    const [files, total] = await Promise.all([
      this.prisma.attachment.findMany({
        where,
        include: {
          post: {
            select: {
              id: true,
              title: true,
            },
          },
          uploader: {
            select: {
              id: true,
              username: true,
              name: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit,
      }),
      this.prisma.attachment.count({ where }),
    ]);

    return {
      success: true,
      message: `Found ${total} file(s)`,
      data: {
        files,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasMore: page * limit < total,
        },
      },
    };
  }

  /**
   * 搜尋標籤
   */
  async searchTags(params: {
    query: string;
    page: number;
    limit: number;
  }) {
    const { query, page, limit } = params;
    const skip = (page - 1) * limit;

    const where = {
      OR: [
        { name: { contains: query, mode: 'insensitive' as const } },
        { slug: { contains: query, mode: 'insensitive' as const } },
        { description: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    const [tags, total] = await Promise.all([
      this.prisma.tag.findMany({
        where,
        orderBy: { postsCount: 'desc' },  // 按使用次數排序
        skip,
        take: limit,
      }),
      this.prisma.tag.count({ where }),
    ]);

    return {
      success: true,
      message: `Found ${total} tag(s)`,
      data: {
        tags,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasMore: page * limit < total,
        },
      },
    };
  }

  /**
   * 獲取搜尋建議
   */
  async getSuggestions(query: string) {
    // 獲取匹配的標籤（前 5 個）
    const tags = await this.prisma.tag.findMany({
      where: {
        name: { contains: query, mode: 'insensitive' },
      },
      select: { name: true, postsCount: true },
      orderBy: { postsCount: 'desc' },
      take: 5,
    });

    // 獲取匹配的用戶（前 3 個）
    const users = await this.prisma.user.findMany({
      where: {
        OR: [
          { username: { contains: query, mode: 'insensitive' } },
          { name: { contains: query, mode: 'insensitive' } },
        ],
      },
      select: { username: true, name: true, avatar: true },
      take: 3,
    });

    return {
      success: true,
      data: {
        tags: tags.map((t) => ({ text: t.name, type: 'tag', count: t.postsCount })),
        users: users.map((u) => ({
          text: u.name || u.username,
          type: 'user',
          avatar: u.avatar,
        })),
      },
    };
  }

  /**
   * 保存搜尋歷史
   */
  async saveSearchHistory(userId: string, query: string, type: string) {
    try {
      await this.prisma.searchHistory.create({
        data: {
          userId,
          query,
          type,
        },
      });
    } catch (error) {
      // 忽略錯誤，搜尋歷史不是關鍵功能
      console.error('Failed to save search history:', error);
    }
  }

  /**
   * 獲取搜尋歷史
   */
  async getSearchHistory(userId: string) {
    const history = await this.prisma.searchHistory.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      take: 10,
      select: {
        query: true,
        type: true,
        createdAt: true,
      },
    });

    return {
      success: true,
      data: { history },
    };
  }
}
```

### 4.3 TagsController（Hashtag 管理）

```typescript
// backend/src/tags/tags.controller.ts

import { Controller, Get, Post, Delete, Param, Body, Query, UseGuards, Request } from '@nestjs/common';
import { TagsService } from './tags.service';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';

@Controller('tags')
export class TagsController {
  constructor(private readonly tagsService: TagsService) {}

  /**
   * 獲取所有標籤
   */
  @Get()
  async getTags(
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    return this.tagsService.getTags({
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 20,
    });
  }

  /**
   * 獲取熱門標籤
   */
  @Get('popular')
  async getPopularTags(@Query('limit') limit?: string) {
    return this.tagsService.getPopularTags(parseInt(limit) || 10);
  }

  /**
   * 獲取標籤詳情
   */
  @Get(':slug')
  async getTag(@Param('slug') slug: string) {
    return this.tagsService.getTag(slug);
  }

  /**
   * 獲取標籤下的文章
   */
  @Get(':slug/posts')
  async getTagPosts(
    @Param('slug') slug: string,
    @Query('page') page?: string,
    @Query('limit') limit?: string,
    @Query('sort') sort?: 'latest' | 'popular',
  ) {
    return this.tagsService.getTagPosts({
      slug,
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
      sort: sort || 'latest',
    });
  }
}

/**
 * Posts Tags Controller（文章標籤管理）
 */
@Controller('posts')
export class PostsTagsController {
  constructor(private readonly tagsService: TagsService) {}

  /**
   * 為文章添加標籤
   */
  @UseGuards(JwtAuthGuard)
  @Post(':id/tags')
  async addPostTags(
    @Param('id') postId: string,
    @Body('tags') tags: string[],  // 標籤名稱數組
    @Request() req,
  ) {
    return this.tagsService.addPostTags(postId, tags, req.user.id);
  }

  /**
   * 移除文章標籤
   */
  @UseGuards(JwtAuthGuard)
  @Delete(':id/tags/:tagId')
  async removePostTag(
    @Param('id') postId: string,
    @Param('tagId') tagId: string,
    @Request() req,
  ) {
    return this.tagsService.removePostTag(postId, tagId, req.user.id);
  }
}
```

### 4.4 TagsService

```typescript
// backend/src/tags/tags.service.ts

import { Injectable, NotFoundException, ForbiddenException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class TagsService {
  constructor(private prisma: PrismaService) {}

  /**
   * 創建或獲取標籤（內部使用）
   */
  private async createOrGetTag(name: string) {
    const slug = name.toLowerCase().replace(/\s+/g, '-');
    
    // 嘗試獲取現有標籤
    let tag = await this.prisma.tag.findUnique({
      where: { slug },
    });

    // 如果不存在，創建新標籤
    if (!tag) {
      tag = await this.prisma.tag.create({
        data: {
          name,
          slug,
        },
      });
    }

    return tag;
  }

  /**
   * 為文章添加標籤
   */
  async addPostTags(postId: string, tagNames: string[], userId: string) {
    // 驗證文章所有權
    const post = await this.prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      throw new NotFoundException('Post not found');
    }

    if (post.authorId !== userId) {
      throw new ForbiddenException('Not authorized');
    }

    // 創建或獲取標籤
    const tags = await Promise.all(
      tagNames.map((name) => this.createOrGetTag(name))
    );

    // 關聯標籤到文章
    await Promise.all(
      tags.map((tag) =>
        this.prisma.postTag.upsert({
          where: {
            postId_tagId: {
              postId,
              tagId: tag.id,
            },
          },
          create: {
            postId,
            tagId: tag.id,
          },
          update: {},
        })
      )
    );

    // 更新標籤的文章計數
    await Promise.all(
      tags.map((tag) =>
        this.prisma.tag.update({
          where: { id: tag.id },
          data: {
            postsCount: {
              increment: 1,
            },
          },
        })
      )
    );

    return {
      success: true,
      message: 'Tags added successfully',
      data: { tags },
    };
  }

  /**
   * 移除文章標籤
   */
  async removePostTag(postId: string, tagId: string, userId: string) {
    // 驗證文章所有權
    const post = await this.prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      throw new NotFoundException('Post not found');
    }

    if (post.authorId !== userId) {
      throw new ForbiddenException('Not authorized');
    }

    // 移除關聯
    await this.prisma.postTag.delete({
      where: {
        postId_tagId: {
          postId,
          tagId,
        },
      },
    });

    // 更新標籤的文章計數
    await this.prisma.tag.update({
      where: { id: tagId },
      data: {
        postsCount: {
          decrement: 1,
        },
      },
    });

    return {
      success: true,
      message: 'Tag removed successfully',
    };
  }

  /**
   * 獲取所有標籤
   */
  async getTags(params: { page: number; limit: number }) {
    const { page, limit } = params;
    const skip = (page - 1) * limit;

    const [tags, total] = await Promise.all([
      this.prisma.tag.findMany({
        orderBy: [
          { postsCount: 'desc' },
          { name: 'asc' },
        ],
        skip,
        take: limit,
      }),
      this.prisma.tag.count(),
    ]);

    return {
      success: true,
      data: {
        tags,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
        },
      },
    };
  }

  /**
   * 獲取熱門標籤
   */
  async getPopularTags(limit: number) {
    const tags = await this.prisma.tag.findMany({
      orderBy: { postsCount: 'desc' },
      take: limit,
    });

    return {
      success: true,
      data: { tags },
    };
  }

  /**
   * 獲取標籤詳情
   */
  async getTag(slug: string) {
    const tag = await this.prisma.tag.findUnique({
      where: { slug },
    });

    if (!tag) {
      throw new NotFoundException('Tag not found');
    }

    return {
      success: true,
      data: { tag },
    };
  }

  /**
   * 獲取標籤下的文章
   */
  async getTagPosts(params: {
    slug: string;
    page: number;
    limit: number;
    sort: 'latest' | 'popular';
  }) {
    const { slug, page, limit, sort } = params;
    const skip = (page - 1) * limit;

    // 獲取標籤
    const tag = await this.prisma.tag.findUnique({
      where: { slug },
    });

    if (!tag) {
      throw new NotFoundException('Tag not found');
    }

    // 排序邏輯
    let orderBy: any = { createdAt: 'desc' };
    if (sort === 'popular') {
      orderBy = [
        { likesCount: 'desc' },
        { commentsCount: 'desc' },
      ];
    }

    const [postTags, total] = await Promise.all([
      this.prisma.postTag.findMany({
        where: {
          tagId: tag.id,
          post: { isPublished: true },
        },
        include: {
          post: {
            include: {
              author: {
                select: {
                  id: true,
                  username: true,
                  name: true,
                  avatar: true,
                },
              },
              postTags: {
                include: { tag: true },
              },
            },
          },
        },
        skip,
        take: limit,
      }),
      this.prisma.postTag.count({
        where: {
          tagId: tag.id,
          post: { isPublished: true },
        },
      }),
    ]);

    const posts = postTags.map((pt) => pt.post);

    return {
      success: true,
      data: {
        tag,
        posts,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
        },
      },
    };
  }
}
```

---

## 5. 前端實現

### 5.1 搜尋類型定義

```typescript
// frontend/src/types/search.ts

export type SearchType = 'all' | 'posts' | 'users' | 'files' | 'tags';

export interface SearchParams {
  query: string;
  type?: SearchType;
  sort?: 'relevant' | 'latest' | 'popular' | 'followers' | 'posts';
  page?: number;
  limit?: number;
}

export interface SearchResult {
  posts?: Post[];
  users?: User[];
  files?: Attachment[];
  tags?: Tag[];
  pagination?: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasMore: boolean;
  };
}

export interface Tag {
  id: string;
  name: string;
  slug: string;
  description?: string;
  postsCount: number;
  createdAt: string;
}

export interface Attachment {
  id: string;
  filename: string;
  originalName: string;
  url: string;
  mimeType: string;
  size: number;
  createdAt: string;
  post: {
    id: string;
    title: string;
  };
  uploader: {
    id: string;
    username: string;
    name: string;
  };
}

export interface SearchSuggestion {
  text: string;
  type: 'tag' | 'user';
  avatar?: string;
  count?: number;
}
```

### 5.2 搜尋服務

```typescript
// frontend/src/services/search.service.ts

import { apiClient } from './api.client';
import { SearchParams, SearchResult, SearchSuggestion } from '../types/search';

export const searchService = {
  /**
   * 綜合搜尋
   */
  async search(params: SearchParams): Promise<SearchResult> {
    const response = await apiClient.get('/search', { params });
    return response.data;
  },

  /**
   * 搜尋文章
   */
  async searchPosts(params: Omit<SearchParams, 'type'>) {
    const response = await apiClient.get('/search/posts', { params });
    return response.data;
  },

  /**
   * 搜尋用戶
   */
  async searchUsers(params: Omit<SearchParams, 'type'>) {
    const response = await apiClient.get('/search/users', { params });
    return response.data;
  },

  /**
   * 搜尋文件
   */
  async searchFiles(params: Omit<SearchParams, 'type'>) {
    const response = await apiClient.get('/search/files', { params });
    return response.data;
  },

  /**
   * 搜尋標籤
   */
  async searchTags(params: Omit<SearchParams, 'type'>) {
    const response = await apiClient.get('/search/tags', { params });
    return response.data;
  },

  /**
   * 獲取搜尋建議
   */
  async getSuggestions(query: string): Promise<SearchSuggestion[]> {
    if (query.length < 2) return [];
    const response = await apiClient.get('/search/suggestions', {
      params: { q: query },
    });
    return [...response.data.tags, ...response.data.users];
  },

  /**
   * 獲取搜尋歷史
   */
  async getHistory() {
    const response = await apiClient.get('/search/history');
    return response.data.history;
  },
};
```

### 5.3 標籤服務

```typescript
// frontend/src/services/tags.service.ts

import { apiClient } from './api.client';
import { Tag } from '../types/search';

export const tagsService = {
  /**
   * 獲取所有標籤
   */
  async getTags(params: { page?: number; limit?: number } = {}) {
    const response = await apiClient.get('/tags', { params });
    return response.data;
  },

  /**
   * 獲取熱門標籤
   */
  async getPopularTags(limit: number = 10) {
    const response = await apiClient.get('/tags/popular', {
      params: { limit },
    });
    return response.data.tags as Tag[];
  },

  /**
   * 獲取標籤詳情
   */
  async getTag(slug: string) {
    const response = await apiClient.get(`/tags/${slug}`);
    return response.data.tag as Tag;
  },

  /**
   * 獲取標籤下的文章
   */
  async getTagPosts(params: {
    slug: string;
    page?: number;
    limit?: number;
    sort?: 'latest' | 'popular';
  }) {
    const { slug, ...queryParams } = params;
    const response = await apiClient.get(`/tags/${slug}/posts`, {
      params: queryParams,
    });
    return response.data;
  },

  /**
   * 為文章添加標籤
   */
  async addPostTags(postId: string, tags: string[]) {
    const response = await apiClient.post(`/posts/${postId}/tags`, { tags });
    return response.data;
  },

  /**
   * 移除文章標籤
   */
  async removePostTag(postId: string, tagId: string) {
    const response = await apiClient.delete(`/posts/${postId}/tags/${tagId}`);
    return response.data;
  },
};
```

---

## 6. 前端 UI 實現

### 6.1 統一搜尋頁面

```typescript
// frontend/src/screens/SearchScreen.tsx

import React, { useState, useEffect } from 'react';
import { View, FlatList, StyleSheet } from 'react-native';
import {
  Searchbar,
  SegmentedButtons,
  Chip,
  Text,
  Card,
  Avatar,
  IconButton,
  List,
} from 'react-native-paper';
import { searchService } from '../services/search.service';
import { SearchType } from '../types/search';
import PostCard from '../components/common/PostCard';
import UserCard from '../components/common/UserCard';
import FileCard from '../components/common/FileCard';
import TagChip from '../components/common/TagChip';

export default function SearchScreen({ navigation }: any) {
  const [query, setQuery] = useState('');
  const [searchType, setSearchType] = useState<SearchType>('all');
  const [results, setResults] = useState<any>({});
  const [loading, setLoading] = useState(false);
  const [suggestions, setSuggestions] = useState<any[]>([]);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [searchHistory, setSearchHistory] = useState<string[]>([]);

  // 載入搜尋歷史
  useEffect(() => {
    loadSearchHistory();
  }, []);

  // 獲取搜尋建議
  useEffect(() => {
    const timer = setTimeout(async () => {
      if (query.length >= 2) {
        const data = await searchService.getSuggestions(query);
        setSuggestions(data);
        setShowSuggestions(true);
      } else {
        setSuggestions([]);
        setShowSuggestions(false);
      }
    }, 300); // 防抖

    return () => clearTimeout(timer);
  }, [query]);

  const loadSearchHistory = async () => {
    try {
      const history = await searchService.getHistory();
      setSearchHistory(history.map((h: any) => h.query));
    } catch (error) {
      console.error('Load history error:', error);
    }
  };

  const handleSearch = async () => {
    if (!query.trim()) return;

    setLoading(true);
    setShowSuggestions(false);

    try {
      const data = await searchService.search({
        query,
        type: searchType,
      });

      setResults(data);
    } catch (error) {
      console.error('Search error:', error);
    } finally {
      setLoading(false);
    }
  };

  const renderSearchResults = () => {
    if (searchType === 'all') {
      return (
        <View>
          {results.posts?.length > 0 && (
            <View style={styles.section}>
              <Text variant="titleMedium" style={styles.sectionTitle}>
                文章
              </Text>
              {results.posts.map((post: any) => (
                <PostCard key={post.id} post={post} />
              ))}
            </View>
          )}

          {results.users?.length > 0 && (
            <View style={styles.section}>
              <Text variant="titleMedium" style={styles.sectionTitle}>
                用戶
              </Text>
              {results.users.map((user: any) => (
                <UserCard key={user.id} user={user} />
              ))}
            </View>
          )}

          {results.files?.length > 0 && (
            <View style={styles.section}>
              <Text variant="titleMedium" style={styles.sectionTitle}>
                文件
              </Text>
              {results.files.map((file: any) => (
                <FileCard key={file.id} file={file} />
              ))}
            </View>
          )}

          {results.tags?.length > 0 && (
            <View style={styles.section}>
              <Text variant="titleMedium" style={styles.sectionTitle}>
                標籤
              </Text>
              <View style={styles.tagsContainer}>
                {results.tags.map((tag: any) => (
                  <TagChip
                    key={tag.id}
                    tag={tag}
                    onPress={() => navigation.navigate('TagPosts', { slug: tag.slug })}
                  />
                ))}
              </View>
            </View>
          )}
        </View>
      );
    }

    // 單一類型搜尋結果
    const data = results[searchType] || [];
    return (
      <FlatList
        data={data}
        renderItem={({ item }) => {
          if (searchType === 'posts') return <PostCard post={item} />;
          if (searchType === 'users') return <UserCard user={item} />;
          if (searchType === 'files') return <FileCard file={item} />;
          if (searchType === 'tags') {
            return (
              <TagChip
                tag={item}
                onPress={() => navigation.navigate('TagPosts', { slug: item.slug })}
              />
            );
          }
          return null;
        }}
        keyExtractor={(item) => item.id}
      />
    );
  };

  return (
    <View style={styles.container}>
      {/* 搜尋框 */}
      <Searchbar
        placeholder="搜尋文章、用戶、文件、標籤..."
        value={query}
        onChangeText={setQuery}
        onSubmitEditing={handleSearch}
        icon="magnify"
      />

      {/* 搜尋建議 */}
      {showSuggestions && suggestions.length > 0 && (
        <Card style={styles.suggestionsCard}>
          {suggestions.map((suggestion, index) => (
            <List.Item
              key={index}
              title={suggestion.text}
              left={(props) =>
                suggestion.type === 'tag' ? (
                  <List.Icon {...props} icon="pound" />
                ) : (
                  <Avatar.Image
                    {...props}
                    size={40}
                    source={{ uri: suggestion.avatar || 'https://via.placeholder.com/40' }}
                  />
                )
              }
              right={(props) =>
                suggestion.count ? (
                  <Text {...props} variant="bodySmall">
                    {suggestion.count} 篇文章
                  </Text>
                ) : null
              }
              onPress={() => {
                setQuery(suggestion.text);
                handleSearch();
              }}
            />
          ))}
        </Card>
      )}

      {/* 搜尋類型選擇 */}
      <SegmentedButtons
        value={searchType}
        onValueChange={(value) => setSearchType(value as SearchType)}
        buttons={[
          { value: 'all', label: '全部' },
          { value: 'posts', label: '文章' },
          { value: 'users', label: '用戶' },
          { value: 'files', label: '文件' },
          { value: 'tags', label: '標籤' },
        ]}
        style={styles.segmentedButtons}
      />

      {/* 搜尋歷史（當沒有輸入時顯示）*/}
      {!query && searchHistory.length > 0 && (
        <View style={styles.historyContainer}>
          <Text variant="titleSmall" style={styles.historyTitle}>
            最近搜尋
          </Text>
          <View style={styles.historyChips}>
            {searchHistory.map((historyQuery, index) => (
              <Chip
                key={index}
                icon="history"
                onPress={() => {
                  setQuery(historyQuery);
                  handleSearch();
                }}
                style={styles.historyChip}
              >
                {historyQuery}
              </Chip>
            ))}
          </View>
        </View>
      )}

      {/* 搜尋結果 */}
      {renderSearchResults()}

      {/* 空狀態 */}
      {!loading && query && Object.keys(results).length === 0 && (
        <View style={styles.emptyState}>
          <Text>沒有找到相關結果</Text>
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  segmentedButtons: {
    marginVertical: 12,
  },
  section: {
    marginBottom: 24,
  },
  sectionTitle: {
    marginBottom: 12,
    fontWeight: 'bold',
  },
  tagsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  suggestionsCard: {
    marginTop: 8,
    marginBottom: 8,
  },
  historyContainer: {
    marginVertical: 16,
  },
  historyTitle: {
    marginBottom: 8,
    opacity: 0.7,
  },
  historyChips: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  historyChip: {
    marginBottom: 8,
  },
  emptyState: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});
```

### 6.2 標籤文章頁面

```typescript
// frontend/src/screens/TagPostsScreen.tsx

import React, { useEffect, useState } from 'react';
import { View, FlatList, StyleSheet } from 'react-native';
import { Text, Chip, Appbar } from 'react-native-paper';
import { tagsService } from '../services/tags.service';
import PostCard from '../components/common/PostCard';

export default function TagPostsScreen({ route, navigation }: any) {
  const { slug } = route.params;
  const [tag, setTag] = useState<any>(null);
  const [posts, setPosts] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadTagPosts();
  }, [slug]);

  const loadTagPosts = async () => {
    try {
      const data = await tagsService.getTagPosts({ slug });
      setTag(data.tag);
      setPosts(data.posts);
    } catch (error) {
      console.error('Load tag posts error:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={styles.container}>
      <Appbar.Header>
        <Appbar.BackAction onPress={() => navigation.goBack()} />
        <Appbar.Content title={`#${tag?.name}`} />
      </Appbar.Header>

      {tag && (
        <View style={styles.header}>
          <Text variant="headlineMedium">#{tag.name}</Text>
          {tag.description && (
            <Text variant="bodyMedium" style={styles.description}>
              {tag.description}
            </Text>
          )}
          <Chip icon="file-document" style={styles.chip}>
            {tag.postsCount} 篇文章
          </Chip>
        </View>
      )}

      <FlatList
        data={posts}
        renderItem={({ item }) => <PostCard post={item} />}
        keyExtractor={(item) => item.id}
        refreshing={loading}
        onRefresh={loadTagPosts}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  description: {
    marginTop: 8,
    opacity: 0.7,
  },
  chip: {
    marginTop: 12,
    alignSelf: 'flex-start',
  },
});
```

---

## 7. 數據庫遷移

### 7.1 創建遷移

```bash
# 創建遷移
npx prisma migrate dev --name add_search_features

# 生成 Prisma Client
npx prisma generate
```

### 7.2 數據填充（測試數據）

```typescript
// prisma/seed-search.ts

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function seedTags() {
  console.log('Seeding tags...');

  const tags = [
    { name: '旅遊', slug: 'travel', description: '分享旅遊經歷和景點' },
    { name: '美食', slug: 'food', description: '美食推薦和烹飪分享' },
    { name: '科技', slug: 'tech', description: '科技新聞和產品評測' },
    { name: '生活', slug: 'lifestyle', description: '日常生活分享' },
    { name: '攝影', slug: 'photography', description: '攝影作品和技巧' },
    { name: '運動', slug: 'sports', description: '運動健身相關' },
    { name: '音樂', slug: 'music', description: '音樂推薦和分享' },
    { name: '電影', slug: 'movies', description: '電影評論和推薦' },
  ];

  for (const tagData of tags) {
    await prisma.tag.upsert({
      where: { slug: tagData.slug },
      update: {},
      create: tagData,
    });
  }

  console.log(`Created ${tags.length} tags`);
}

async function seedPostTags() {
  console.log('Assigning tags to posts...');

  const posts = await prisma.post.findMany();
  const tags = await prisma.tag.findMany();

  for (const post of posts) {
    // 隨機分配 1-3 個標籤
    const numTags = Math.floor(Math.random() * 3) + 1;
    const randomTags = tags
      .sort(() => 0.5 - Math.random())
      .slice(0, numTags);

    for (const tag of randomTags) {
      await prisma.postTag.upsert({
        where: {
          postId_tagId: {
            postId: post.id,
            tagId: tag.id,
          },
        },
        update: {},
        create: {
          postId: post.id,
          tagId: tag.id,
        },
      });

      // 更新標籤文章計數
      await prisma.tag.update({
        where: { id: tag.id },
        data: {
          postsCount: {
            increment: 1,
          },
        },
      });
    }
  }

  console.log('Post tags assigned');
}

async function main() {
  await seedTags();
  await seedPostTags();
  console.log('Search features seeded successfully!');
}

main()
  .catch(console.error)
  .finally(() => prisma.$disconnect());
```

---

## 8. 實施計劃

### 8.1 開發階段

| 階段 | 任務 | 時間 | 優先級 |
|-----|------|------|--------|
| **階段 1** | 數據模型設計和遷移 | 0.5 天 | ⭐⭐⭐⭐⭐ |
| - | 創建 Attachment、Tag、PostTag、SearchHistory 模型 | | |
| - | 執行數據庫遷移 | | |
| - | 添加必要的索引 | | |
| **階段 2** | 後端 API 實現 | 2-3 天 | ⭐⭐⭐⭐⭐ |
| - | SearchController + SearchService | | |
| - | TagsController + TagsService | | |
| - | 實現所有搜尋 API | | |
| **階段 3** | 前端實現 | 2-3 天 | ⭐⭐⭐⭐⭐ |
| - | 搜尋服務層 | | |
| - | 統一搜尋頁面 UI | | |
| - | 標籤相關頁面 | | |
| **階段 4** | 測試和優化 | 1 天 | ⭐⭐⭐⭐ |
| - | API 測試 | | |
| - | 用戶體驗測試 | | |
| - | 性能優化 | | |

**總時間：6-8 天** ✅

---

## 9. 架構設計：為 Elasticsearch 做準備

### 9.1 抽象搜尋接口（關鍵設計）

為了將來能無縫切換到 Elasticsearch，我們採用 **接口抽象** 設計：

```typescript
// backend/src/search/interfaces/search-engine.interface.ts

export interface ISearchEngine {
  // 索引操作
  indexPost(postId: string): Promise<void>;
  updatePost(postId: string): Promise<void>;
  deletePost(postId: string): Promise<void>;
  
  // 批量操作
  bulkIndexPosts(postIds: string[]): Promise<void>;
  
  // 搜尋操作
  searchPosts(params: SearchParams): Promise<SearchResult>;
  searchUsers(params: SearchParams): Promise<SearchResult>;
  searchFiles(params: SearchParams): Promise<SearchResult>;
  searchTags(params: SearchParams): Promise<SearchResult>;
  
  // 建議和統計
  getSuggestions(query: string): Promise<Suggestion[]>;
}

export interface SearchParams {
  query: string;
  page: number;
  limit: number;
  sort?: string;
  filters?: Record<string, any>;
}

export interface SearchResult {
  items: any[];
  total: number;
  page: number;
  limit: number;
  hasMore: boolean;
}
```

### 9.2 PostgreSQL 實現（當前）

```typescript
// backend/src/search/engines/postgres-search.engine.ts

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { ISearchEngine, SearchParams, SearchResult } from '../interfaces/search-engine.interface';

@Injectable()
export class PostgresSearchEngine implements ISearchEngine {
  constructor(private prisma: PrismaService) {}

  // 索引操作（PostgreSQL 中這些是空操作，因為數據已在數據庫中）
  async indexPost(postId: string): Promise<void> {
    // PostgreSQL 不需要顯式索引，但保留接口以便將來遷移
    console.log(`[PostgreSQL] Post ${postId} already in database`);
  }

  async updatePost(postId: string): Promise<void> {
    // PostgreSQL 通過 Prisma 自動更新
    console.log(`[PostgreSQL] Post ${postId} updated in database`);
  }

  async deletePost(postId: string): Promise<void> {
    // PostgreSQL 通過 Prisma 自動刪除
    console.log(`[PostgreSQL] Post ${postId} deleted from database`);
  }

  async bulkIndexPosts(postIds: string[]): Promise<void> {
    console.log(`[PostgreSQL] Bulk indexing ${postIds.length} posts`);
  }

  // 搜尋實現
  async searchPosts(params: SearchParams): Promise<SearchResult> {
    const { query, page, limit, sort } = params;
    const skip = (page - 1) * limit;

    const where = {
      isPublished: true,
      OR: [
        { title: { contains: query, mode: 'insensitive' as const } },
        { content: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    let orderBy: any = { createdAt: 'desc' };
    if (sort === 'popular') {
      orderBy = [
        { likesCount: 'desc' },
        { commentsCount: 'desc' },
      ];
    }

    const [items, total] = await Promise.all([
      this.prisma.post.findMany({
        where,
        include: {
          author: {
            select: {
              id: true,
              username: true,
              name: true,
              avatar: true,
            },
          },
          postTags: {
            include: { tag: true },
          },
        },
        orderBy,
        skip,
        take: limit,
      }),
      this.prisma.post.count({ where }),
    ]);

    return {
      items,
      total,
      page,
      limit,
      hasMore: page * limit < total,
    };
  }

  async searchUsers(params: SearchParams): Promise<SearchResult> {
    const { query, page, limit, sort } = params;
    const skip = (page - 1) * limit;

    const where = {
      OR: [
        { username: { contains: query, mode: 'insensitive' as const } },
        { name: { contains: query, mode: 'insensitive' as const } },
        { bio: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    let orderBy: any = { followersCount: 'desc' };
    if (sort === 'posts') {
      orderBy = { postsCount: 'desc' };
    }

    const [items, total] = await Promise.all([
      this.prisma.user.findMany({
        where,
        select: {
          id: true,
          username: true,
          name: true,
          bio: true,
          avatar: true,
          location: true,
          followersCount: true,
          followingCount: true,
          postsCount: true,
        },
        orderBy,
        skip,
        take: limit,
      }),
      this.prisma.user.count({ where }),
    ]);

    return {
      items,
      total,
      page,
      limit,
      hasMore: page * limit < total,
    };
  }

  async searchFiles(params: SearchParams): Promise<SearchResult> {
    const { query, page, limit } = params;
    const skip = (page - 1) * limit;

    const where = {
      OR: [
        { filename: { contains: query, mode: 'insensitive' as const } },
        { originalName: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    const [items, total] = await Promise.all([
      this.prisma.attachment.findMany({
        where,
        include: {
          post: { select: { id: true, title: true } },
          uploader: { select: { id: true, username: true, name: true } },
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit,
      }),
      this.prisma.attachment.count({ where }),
    ]);

    return {
      items,
      total,
      page,
      limit,
      hasMore: page * limit < total,
    };
  }

  async searchTags(params: SearchParams): Promise<SearchResult> {
    const { query, page, limit } = params;
    const skip = (page - 1) * limit;

    const where = {
      OR: [
        { name: { contains: query, mode: 'insensitive' as const } },
        { slug: { contains: query, mode: 'insensitive' as const } },
        { description: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    const [items, total] = await Promise.all([
      this.prisma.tag.findMany({
        where,
        orderBy: { postsCount: 'desc' },
        skip,
        take: limit,
      }),
      this.prisma.tag.count({ where }),
    ]);

    return {
      items,
      total,
      page,
      limit,
      hasMore: page * limit < total,
    };
  }

  async getSuggestions(query: string): Promise<any[]> {
    const [tags, users] = await Promise.all([
      this.prisma.tag.findMany({
        where: { name: { contains: query, mode: 'insensitive' } },
        select: { name: true, postsCount: true },
        orderBy: { postsCount: 'desc' },
        take: 5,
      }),
      this.prisma.user.findMany({
        where: {
          OR: [
            { username: { contains: query, mode: 'insensitive' } },
            { name: { contains: query, mode: 'insensitive' } },
          ],
        },
        select: { username: true, name: true, avatar: true },
        take: 3,
      }),
    ]);

    return [
      ...tags.map((t) => ({ text: t.name, type: 'tag', count: t.postsCount })),
      ...users.map((u) => ({ text: u.name || u.username, type: 'user', avatar: u.avatar })),
    ];
  }
}
```

### 9.3 Elasticsearch 實現（未來）

```typescript
// backend/src/search/engines/elasticsearch.engine.ts
// 這是將來遷移時的實現示例，現在不需要安裝

import { Injectable } from '@nestjs/common';
import { Client } from '@elastic/elasticsearch';
import { PrismaService } from '../../prisma/prisma.service';
import { ISearchEngine, SearchParams, SearchResult } from '../interfaces/search-engine.interface';

@Injectable()
export class ElasticsearchEngine implements ISearchEngine {
  private client: Client;
  
  constructor(private prisma: PrismaService) {
    // 將來啟用時取消註釋
    // this.client = new Client({
    //   node: process.env.ELASTICSEARCH_URL || 'http://localhost:9200',
    // });
  }

  async indexPost(postId: string): Promise<void> {
    const post = await this.prisma.post.findUnique({
      where: { id: postId },
      include: {
        author: { select: { id: true, name: true, username: true } },
        postTags: { include: { tag: true } },
      },
    });

    if (!post) return;

    await this.client.index({
      index: 'posts',
      id: post.id,
      document: {
        id: post.id,
        title: post.title,
        content: post.content,
        authorId: post.authorId,
        authorName: post.author.name || post.author.username,
        tags: post.postTags.map(pt => pt.tag.name),
        createdAt: post.createdAt,
        likesCount: post.likesCount,
        commentsCount: post.commentsCount,
      },
    });
  }

  async updatePost(postId: string): Promise<void> {
    await this.indexPost(postId); // 重新索引即是更新
  }

  async deletePost(postId: string): Promise<void> {
    await this.client.delete({
      index: 'posts',
      id: postId,
    });
  }

  async bulkIndexPosts(postIds: string[]): Promise<void> {
    const operations = postIds.flatMap(id => [
      { index: { _index: 'posts', _id: id } },
      { id }, // 文檔數據將在索引時獲取
    ]);

    await this.client.bulk({ operations });
  }

  async searchPosts(params: SearchParams): Promise<SearchResult> {
    const { query, page, limit, sort } = params;
    const from = (page - 1) * limit;

    const result = await this.client.search({
      index: 'posts',
      body: {
        from,
        size: limit,
        query: {
          multi_match: {
            query,
            fields: ['title^3', 'content', 'authorName^2'],
            fuzziness: 'AUTO',
          },
        },
        sort: sort === 'popular' 
          ? [{ likesCount: 'desc' }, { commentsCount: 'desc' }]
          : [{ _score: 'desc' }, { createdAt: 'desc' }],
      },
    });

    return {
      items: result.hits.hits.map(hit => hit._source),
      total: result.hits.total.value,
      page,
      limit,
      hasMore: page * limit < result.hits.total.value,
    };
  }

  // ... 其他方法類似實現
}
```

### 9.4 搜尋服務（使用抽象接口）

```typescript
// backend/src/search/search.service.ts

import { Injectable, Inject } from '@nestjs/common';
import { ISearchEngine } from './interfaces/search-engine.interface';

@Injectable()
export class SearchService {
  constructor(
    @Inject('SEARCH_ENGINE')
    private searchEngine: ISearchEngine,  // 注入抽象接口，而非具體實現
  ) {}

  async search(params: {
    query: string;
    type: 'all' | 'posts' | 'users' | 'files' | 'tags';
    page: number;
    limit: number;
  }) {
    const { query, type, page, limit } = params;

    if (type === 'posts') {
      const result = await this.searchEngine.searchPosts({ query, page, limit });
      return {
        success: true,
        data: {
          posts: result.items,
          pagination: {
            page: result.page,
            limit: result.limit,
            total: result.total,
            hasMore: result.hasMore,
          },
        },
      };
    }

    if (type === 'users') {
      const result = await this.searchEngine.searchUsers({ query, page, limit });
      return {
        success: true,
        data: {
          users: result.items,
          pagination: {
            page: result.page,
            limit: result.limit,
            total: result.total,
            hasMore: result.hasMore,
          },
        },
      };
    }

    if (type === 'files') {
      const result = await this.searchEngine.searchFiles({ query, page, limit });
      return {
        success: true,
        data: {
          files: result.items,
          pagination: {
            page: result.page,
            limit: result.limit,
            total: result.total,
            hasMore: result.hasMore,
          },
        },
      };
    }

    if (type === 'tags') {
      const result = await this.searchEngine.searchTags({ query, page, limit });
      return {
        success: true,
        data: {
          tags: result.items,
          pagination: {
            page: result.page,
            limit: result.limit,
            total: result.total,
            hasMore: result.hasMore,
          },
        },
      };
    }

    // type === 'all'
    const [posts, users, files, tags] = await Promise.all([
      this.searchEngine.searchPosts({ query, page: 1, limit: 5 }),
      this.searchEngine.searchUsers({ query, page: 1, limit: 5 }),
      this.searchEngine.searchFiles({ query, page: 1, limit: 5 }),
      this.searchEngine.searchTags({ query, page: 1, limit: 5 }),
    ]);

    return {
      success: true,
      data: {
        posts: posts.items,
        users: users.items,
        files: files.items,
        tags: tags.items,
      },
    };
  }

  async getSuggestions(query: string) {
    const suggestions = await this.searchEngine.getSuggestions(query);
    return {
      success: true,
      data: { suggestions },
    };
  }
}
```

### 9.5 模塊配置（切換引擎）

```typescript
// backend/src/search/search.module.ts

import { Module } from '@nestjs/common';
import { SearchController } from './search.controller';
import { SearchService } from './search.service';
import { PostgresSearchEngine } from './engines/postgres-search.engine';
// import { ElasticsearchEngine } from './engines/elasticsearch.engine'; // 未來啟用

@Module({
  controllers: [SearchController],
  providers: [
    SearchService,
    {
      provide: 'SEARCH_ENGINE',
      useClass: PostgresSearchEngine,  // 當前使用 PostgreSQL
      // useClass: ElasticsearchEngine,  // 將來切換到 Elasticsearch 只需改這一行
    },
  ],
  exports: [SearchService],
})
export class SearchModule {}
```

### 9.6 環境變數配置

```bash
# backend/.env

# 搜尋引擎配置
SEARCH_ENGINE=postgres  # 可選：postgres, elasticsearch

# Elasticsearch 配置（未來使用）
# ELASTICSEARCH_URL=http://localhost:9200
# ELASTICSEARCH_USERNAME=elastic
# ELASTICSEARCH_PASSWORD=your_password
```

### 9.7 PostService 集成（支持任何搜尋引擎）

```typescript
// backend/src/posts/posts.service.ts

import { Injectable, Inject } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { ISearchEngine } from '../search/interfaces/search-engine.interface';

@Injectable()
export class PostsService {
  constructor(
    private prisma: PrismaService,
    @Inject('SEARCH_ENGINE')
    private searchEngine: ISearchEngine,  // 注入搜尋引擎接口
  ) {}

  async createPost(data: CreatePostDto, userId: string) {
    const post = await this.prisma.post.create({
      data: {
        ...data,
        authorId: userId,
      },
    });

    // 自動索引（PostgreSQL 是空操作，Elasticsearch 會真正索引）
    await this.searchEngine.indexPost(post.id);

    return post;
  }

  async updatePost(postId: string, data: UpdatePostDto, userId: string) {
    const post = await this.prisma.post.update({
      where: { id: postId, authorId: userId },
      data,
    });

    // 更新索引
    await this.searchEngine.updatePost(post.id);

    return post;
  }

  async deletePost(postId: string, userId: string) {
    await this.prisma.post.delete({
      where: { id: postId, authorId: userId },
    });

    // 刪除索引
    await this.searchEngine.deletePost(postId);

    return { success: true };
  }
}
```

---

## 9.8 遷移到 Elasticsearch 的步驟（未來）

當需要遷移時，只需要：

**步驟 1：安裝依賴**
```bash
npm install @elastic/elasticsearch
```

**步驟 2：啟動 Elasticsearch**
```bash
# 使用 Docker
docker run -d \
  --name elasticsearch \
  -p 9200:9200 \
  -e "discovery.type=single-node" \
  -e "xpack.security.enabled=false" \
  docker.elastic.co/elasticsearch/elasticsearch:8.11.0
```

**步驟 3：修改配置**
```typescript
// backend/src/search/search.module.ts
{
  provide: 'SEARCH_ENGINE',
  useClass: ElasticsearchEngine,  // 改這一行
}
```

**步驟 4：初始化索引**
```bash
# 執行遷移腳本（批量索引現有數據）
npm run search:reindex
```

**完成！** 前端代碼無需任何修改。

---

## 9.9 性能優化

### 數據庫索引（PostgreSQL）
```sql
-- 文章搜尋
CREATE INDEX idx_posts_title_search ON posts(title);
CREATE INDEX idx_posts_content_search ON posts USING gin(to_tsvector('simple', content));

-- 用戶搜尋
CREATE INDEX idx_users_username_search ON users(username);
CREATE INDEX idx_users_name_search ON users(name);

-- 標籤搜尋
CREATE INDEX idx_tags_name_search ON tags(name);
CREATE INDEX idx_tags_slug_search ON tags(slug);

-- 文件搜尋
CREATE INDEX idx_attachments_filename_search ON attachments(filename);
CREATE INDEX idx_attachments_original_name_search ON attachments(original_name);
```

### 緩存策略
```typescript
// 緩存熱門標籤
import { Redis } from 'ioredis';
const redis = new Redis();

async getPopularTags(limit: number) {
  const cacheKey = `tags:popular:${limit}`;
  const cached = await redis.get(cacheKey);
  
  if (cached) {
    return JSON.parse(cached);
  }
  
  const tags = await this.prisma.tag.findMany({
    orderBy: { postsCount: 'desc' },
    take: limit,
  });
  
  await redis.set(cacheKey, JSON.stringify(tags), 'EX', 3600); // 1 小時
  return tags;
}
```

---

## 10. 總結

### 10.1 完整功能清單

✅ **文章搜尋**
- 標題和內容搜尋
- 多種排序（最新、熱門）
- 分頁支持

✅ **用戶搜尋**
- 用戶名、名稱、簡介搜尋
- 按粉絲數或發文數排序
- 用戶卡片展示

✅ **文件搜尋**
- 文件名稱模糊搜尋
- 文件類型識別
- 關聯文章顯示

✅ **Hashtag 搜尋**
- 標籤名稱搜尋
- 標籤詳情頁面
- 標籤下文章列表
- 文章標籤管理

✅ **進階功能**
- 統一搜尋界面
- 搜尋建議（自動完成）
- 搜尋歷史
- 分類篩選

### 10.2 技術亮點

1. **統一 API 設計**：一致的接口風格
2. **模糊搜尋**：PostgreSQL ILIKE 支持
3. **性能優化**：適當的索引和緩存
4. **用戶體驗**：搜尋建議和歷史記錄
5. **可擴展性**：易於添加新的搜尋類型

### 10.3 實施建議

**推薦立即實施：** ✅
- 需求明確（文章、用戶、文件、標籤）
- 開發時間合理（6-8 天）
- 技術方案成熟
- 用戶價值高

---

**文檔版本：** v1.0  
**創建日期：** 2025-10-29  
**作者：** HAPPY SHARE 開發團隊  
**狀態：** ✅ 推薦實施  
**預計時間：** 6-8 天  
**優先級：** ⭐⭐⭐⭐⭐ 高
