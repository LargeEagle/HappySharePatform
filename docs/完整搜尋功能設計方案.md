# HAPPY SHARE å®Œæ•´æœå°‹åŠŸèƒ½è¨­è¨ˆæ–¹æ¡ˆ

## 1. åŠŸèƒ½æ¦‚è¿°

### 1.1 æœå°‹ç¯„åœ
- ğŸ“ **æ–‡ç« æœå°‹**ï¼šæ¨™é¡Œã€å…§å®¹
- ğŸ‘¤ **ç”¨æˆ¶æœå°‹**ï¼šç”¨æˆ¶åã€é¡¯ç¤ºåç¨±ã€å€‹äººç°¡ä»‹
- ğŸ“„ **æª”æ¡ˆæœå°‹**ï¼šæ–‡ä»¶åç¨±ï¼ˆæ¨¡ç³ŠåŒ¹é…ï¼‰
- ğŸ·ï¸ **Hashtag æœå°‹**ï¼šæ¨™ç±¤åç¨±ã€ç›¸é—œæ–‡ç« 

### 1.2 æ ¸å¿ƒç‰¹é»
- âš¡ çµ±ä¸€æœå°‹ç•Œé¢
- ğŸ” æ¨¡ç³Šæœå°‹æ”¯æŒ
- ğŸ¯ åˆ†é¡ç¯©é¸
- ğŸ“Š æœå°‹çµæœæ’åº
- ğŸ’¾ æœå°‹æ­·å²

---

## 2. æ•¸æ“šæ¨¡å‹è¨­è¨ˆ

### 2.1 å®Œæ•´ Prisma Schema

```prisma
// ===== ç¾æœ‰æ¨¡å‹ï¼ˆéœ€è¦æ“´å±•ï¼‰=====

model User {
  id              String    @id @default(uuid())
  username        String    @unique
  email           String    @unique
  password        String
  name            String?
  bio             String?   @db.Text
  avatar          String?
  location        String?
  website         String?
  postsCount      Int       @default(0)
  followersCount  Int       @default(0)
  followingCount  Int       @default(0)
  totalLikes      Int       @default(0)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // é—œè¯
  posts           Post[]
  comments        Comment[]
  likes           Like[]
  bookmarks       Bookmark[]
  attachments     Attachment[]  // æ–°å¢
  
  @@index([username])   // æœå°‹ç´¢å¼•
  @@index([name])       // æœå°‹ç´¢å¼•
  @@map("users")
}

model Post {
  id              String    @id @default(uuid())
  title           String
  content         String    @db.Text
  image           String?
  isPublished     Boolean   @default(true)
  likesCount      Int       @default(0)
  commentsCount   Int       @default(0)
  bookmarksCount  Int       @default(0)
  authorId        String
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // é—œè¯
  author          User         @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments        Comment[]
  likes           Like[]
  bookmarks       Bookmark[]
  attachments     Attachment[] // æ–°å¢
  postTags        PostTag[]    // æ–°å¢ï¼šæ–‡ç« æ¨™ç±¤é—œè¯
  
  @@index([authorId])
  @@index([createdAt])
  @@index([isPublished])
  @@index([title])          // æ–°å¢ï¼šæ¨™é¡Œæœå°‹ç´¢å¼•
  @@index([isPublished, likesCount])  // æ–°å¢ï¼šç†±é–€æ’åºç´¢å¼•
  @@map("posts")
}

// ===== æ–°å¢æ¨¡å‹ =====

// é™„ä»¶æ¨¡å‹ï¼ˆæ–‡ä»¶æœå°‹ï¼‰
model Attachment {
  id           String   @id @default(uuid())
  filename     String   // ç³»çµ±ç”Ÿæˆçš„æ–‡ä»¶å
  originalName String   // åŸå§‹æ–‡ä»¶åï¼ˆç”¨æˆ¶ä¸Šå‚³æ™‚çš„åç¨±ï¼‰
  url          String   // æ–‡ä»¶ URL
  mimeType     String   // æ–‡ä»¶é¡å‹
  size         Int      // æ–‡ä»¶å¤§å°ï¼ˆbytesï¼‰
  
  postId       String
  uploaderId   String
  createdAt    DateTime @default(now())
  
  // é—œè¯
  post         Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  uploader     User     @relation(fields: [uploaderId], references: [id], onDelete: Cascade)
  
  @@index([filename])      // æ–‡ä»¶åæœå°‹ç´¢å¼•
  @@index([originalName])  // åŸå§‹åç¨±æœå°‹ç´¢å¼•
  @@index([postId])
  @@map("attachments")
}

// Hashtag æ¨™ç±¤æ¨¡å‹
model Tag {
  id          String    @id @default(uuid())
  name        String    @unique  // æ¨™ç±¤åç¨±ï¼ˆå¦‚ï¼šæ—…éŠã€ç¾é£Ÿï¼‰
  slug        String    @unique  // URL å‹å¥½çš„æ¨™ç±¤ï¼ˆå¦‚ï¼štravelã€foodï¼‰
  description String?   @db.Text // æ¨™ç±¤æè¿°
  postsCount  Int       @default(0)  // ä½¿ç”¨æ­¤æ¨™ç±¤çš„æ–‡ç« æ•¸
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // é—œè¯
  postTags    PostTag[]
  
  @@index([name])       // æ¨™ç±¤åç¨±æœå°‹ç´¢å¼•
  @@index([slug])       // URL slug ç´¢å¼•
  @@index([postsCount]) // ç†±é–€æ¨™ç±¤æ’åºç´¢å¼•
  @@map("tags")
}

// æ–‡ç« -æ¨™ç±¤ é—œè¯è¡¨ï¼ˆå¤šå°å¤šï¼‰
model PostTag {
  id        String   @id @default(uuid())
  postId    String
  tagId     String
  createdAt DateTime @default(now())
  
  // é—œè¯
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  @@unique([postId, tagId])  // ç¢ºä¿åŒä¸€æ–‡ç« ä¸æœƒé‡è¤‡æ·»åŠ ç›¸åŒæ¨™ç±¤
  @@index([postId])
  @@index([tagId])
  @@map("post_tags")
}

// æœå°‹æ­·å²æ¨¡å‹ï¼ˆå¯é¸ï¼‰
model SearchHistory {
  id        String   @id @default(uuid())
  userId    String?  // null è¡¨ç¤ºæœªç™»å…¥ç”¨æˆ¶
  query     String   // æœå°‹é—œéµå­—
  type      String   // æœå°‹é¡å‹ï¼šall, posts, users, files, tags
  createdAt DateTime @default(now())
  
  @@index([userId])
  @@index([createdAt])
  @@map("search_history")
}
```

---

## 3. API è¨­è¨ˆ

### 3.1 çµ±ä¸€æœå°‹ API

#### è·¯ç”±çµæ§‹
```
GET  /api/search                          # ç¶œåˆæœå°‹ï¼ˆæ‰€æœ‰é¡å‹ï¼‰
GET  /api/search/posts                    # æœå°‹æ–‡ç« 
GET  /api/search/users                    # æœå°‹ç”¨æˆ¶
GET  /api/search/files                    # æœå°‹æ–‡ä»¶
GET  /api/search/tags                     # æœå°‹æ¨™ç±¤
GET  /api/search/suggestions              # æœå°‹å»ºè­°ï¼ˆè‡ªå‹•å®Œæˆï¼‰
GET  /api/search/history                  # æœå°‹æ­·å²

# Hashtag ç›¸é—œ
GET  /api/tags                            # ç²å–æ‰€æœ‰æ¨™ç±¤
GET  /api/tags/popular                    # ç†±é–€æ¨™ç±¤
GET  /api/tags/:slug                      # ç²å–æ¨™ç±¤è©³æƒ…
GET  /api/tags/:slug/posts                # ç²å–æ¨™ç±¤ä¸‹çš„æ–‡ç« 
POST /api/posts/:id/tags                  # ç‚ºæ–‡ç« æ·»åŠ æ¨™ç±¤
DELETE /api/posts/:id/tags/:tagId         # ç§»é™¤æ–‡ç« æ¨™ç±¤
```

#### æŸ¥è©¢åƒæ•¸
```typescript
interface SearchParams {
  q: string;              // æœå°‹é—œéµå­—ï¼ˆå¿…å¡«ï¼‰
  type?: 'all' | 'posts' | 'users' | 'files' | 'tags';  // æœå°‹é¡å‹
  sort?: 'relevant' | 'latest' | 'popular';  // æ’åºæ–¹å¼
  page?: number;          // é ç¢¼ï¼ˆé»˜èª 1ï¼‰
  limit?: number;         // æ¯é æ•¸é‡ï¼ˆé»˜èª 10ï¼‰
}
```

---

## 4. å¾Œç«¯å¯¦ç¾

### 4.1 SearchController

```typescript
// backend/src/search/search.controller.ts

import { Controller, Get, Query, UseGuards, Request } from '@nestjs/common';
import { SearchService } from './search.service';
import { OptionalJwtAuthGuard } from '../auth/optional-jwt-auth.guard';

@Controller('search')
export class SearchController {
  constructor(private readonly searchService: SearchService) {}

  /**
   * ç¶œåˆæœå°‹ï¼ˆæ‰€æœ‰é¡å‹ï¼‰
   */
  @UseGuards(OptionalJwtAuthGuard)
  @Get()
  async search(
    @Query('q') query: string,
    @Query('type') type?: 'all' | 'posts' | 'users' | 'files' | 'tags',
    @Query('page') page?: string,
    @Query('limit') limit?: string,
    @Request() req?,
  ) {
    if (!query || query.trim().length === 0) {
      return {
        success: false,
        message: 'Search query is required',
      };
    }

    // è¨˜éŒ„æœå°‹æ­·å²
    if (req.user) {
      await this.searchService.saveSearchHistory(
        req.user.id,
        query,
        type || 'all',
      );
    }

    return this.searchService.search({
      query: query.trim(),
      type: type || 'all',
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }

  /**
   * æœå°‹æ–‡ç« 
   */
  @Get('posts')
  async searchPosts(
    @Query('q') query: string,
    @Query('sort') sort?: 'relevant' | 'latest' | 'popular',
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    if (!query) {
      return { success: false, message: 'Query is required' };
    }

    return this.searchService.searchPosts({
      query,
      sort: sort || 'relevant',
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }

  /**
   * æœå°‹ç”¨æˆ¶
   */
  @Get('users')
  async searchUsers(
    @Query('q') query: string,
    @Query('sort') sort?: 'relevant' | 'followers' | 'posts',
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    if (!query) {
      return { success: false, message: 'Query is required' };
    }

    return this.searchService.searchUsers({
      query,
      sort: sort || 'relevant',
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }

  /**
   * æœå°‹æ–‡ä»¶
   */
  @Get('files')
  async searchFiles(
    @Query('q') query: string,
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    if (!query) {
      return { success: false, message: 'Query is required' };
    }

    return this.searchService.searchFiles({
      query,
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }

  /**
   * æœå°‹æ¨™ç±¤
   */
  @Get('tags')
  async searchTags(
    @Query('q') query: string,
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    if (!query) {
      return { success: false, message: 'Query is required' };
    }

    return this.searchService.searchTags({
      query,
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }

  /**
   * æœå°‹å»ºè­°ï¼ˆè‡ªå‹•å®Œæˆï¼‰
   */
  @Get('suggestions')
  async getSuggestions(@Query('q') query: string) {
    if (!query || query.length < 2) {
      return { success: true, data: { suggestions: [] } };
    }

    return this.searchService.getSuggestions(query);
  }

  /**
   * ç²å–æœå°‹æ­·å²
   */
  @UseGuards(OptionalJwtAuthGuard)
  @Get('history')
  async getSearchHistory(@Request() req) {
    if (!req.user) {
      return { success: true, data: { history: [] } };
    }

    return this.searchService.getSearchHistory(req.user.id);
  }
}
```

### 4.2 SearchService

```typescript
// backend/src/search/search.service.ts

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class SearchService {
  constructor(private prisma: PrismaService) {}

  /**
   * ç¶œåˆæœå°‹
   */
  async search(params: {
    query: string;
    type: 'all' | 'posts' | 'users' | 'files' | 'tags';
    page: number;
    limit: number;
  }) {
    const { query, type, page, limit } = params;

    if (type === 'posts') {
      return this.searchPosts({ query, page, limit });
    }
    if (type === 'users') {
      return this.searchUsers({ query, page, limit });
    }
    if (type === 'files') {
      return this.searchFiles({ query, page, limit });
    }
    if (type === 'tags') {
      return this.searchTags({ query, page, limit });
    }

    // type === 'all'ï¼šè¿”å›æ‰€æœ‰é¡å‹çš„çµæœï¼ˆå„å–å‰ 5 å€‹ï¼‰
    const [posts, users, files, tags] = await Promise.all([
      this.searchPosts({ query, page: 1, limit: 5 }),
      this.searchUsers({ query, page: 1, limit: 5 }),
      this.searchFiles({ query, page: 1, limit: 5 }),
      this.searchTags({ query, page: 1, limit: 5 }),
    ]);

    return {
      success: true,
      message: 'Search completed',
      data: {
        query,
        posts: posts.data.posts,
        users: users.data.users,
        files: files.data.files,
        tags: tags.data.tags,
      },
    };
  }

  /**
   * æœå°‹æ–‡ç« 
   */
  async searchPosts(params: {
    query: string;
    sort?: 'relevant' | 'latest' | 'popular';
    page: number;
    limit: number;
  }) {
    const { query, sort = 'relevant', page, limit } = params;
    const skip = (page - 1) * limit;

    const where = {
      isPublished: true,
      OR: [
        { title: { contains: query, mode: 'insensitive' as const } },
        { content: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    // æ’åºé‚è¼¯
    let orderBy: any = { createdAt: 'desc' };
    if (sort === 'popular') {
      orderBy = [
        { likesCount: 'desc' },
        { commentsCount: 'desc' },
        { createdAt: 'desc' },
      ];
    }

    const [posts, total] = await Promise.all([
      this.prisma.post.findMany({
        where,
        include: {
          author: {
            select: {
              id: true,
              username: true,
              name: true,
              avatar: true,
            },
          },
          postTags: {
            include: {
              tag: true,
            },
          },
        },
        orderBy,
        skip,
        take: limit,
      }),
      this.prisma.post.count({ where }),
    ]);

    return {
      success: true,
      message: `Found ${total} post(s)`,
      data: {
        posts,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasMore: page * limit < total,
        },
      },
    };
  }

  /**
   * æœå°‹ç”¨æˆ¶
   */
  async searchUsers(params: {
    query: string;
    sort?: 'relevant' | 'followers' | 'posts';
    page: number;
    limit: number;
  }) {
    const { query, sort = 'relevant', page, limit } = params;
    const skip = (page - 1) * limit;

    const where = {
      OR: [
        { username: { contains: query, mode: 'insensitive' as const } },
        { name: { contains: query, mode: 'insensitive' as const } },
        { bio: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    // æ’åºé‚è¼¯
    let orderBy: any = { followersCount: 'desc' };
    if (sort === 'posts') {
      orderBy = { postsCount: 'desc' };
    }

    const [users, total] = await Promise.all([
      this.prisma.user.findMany({
        where,
        select: {
          id: true,
          username: true,
          name: true,
          bio: true,
          avatar: true,
          location: true,
          followersCount: true,
          followingCount: true,
          postsCount: true,
        },
        orderBy,
        skip,
        take: limit,
      }),
      this.prisma.user.count({ where }),
    ]);

    return {
      success: true,
      message: `Found ${total} user(s)`,
      data: {
        users,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasMore: page * limit < total,
        },
      },
    };
  }

  /**
   * æœå°‹æ–‡ä»¶
   */
  async searchFiles(params: {
    query: string;
    page: number;
    limit: number;
  }) {
    const { query, page, limit } = params;
    const skip = (page - 1) * limit;

    const where = {
      OR: [
        { filename: { contains: query, mode: 'insensitive' as const } },
        { originalName: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    const [files, total] = await Promise.all([
      this.prisma.attachment.findMany({
        where,
        include: {
          post: {
            select: {
              id: true,
              title: true,
            },
          },
          uploader: {
            select: {
              id: true,
              username: true,
              name: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit,
      }),
      this.prisma.attachment.count({ where }),
    ]);

    return {
      success: true,
      message: `Found ${total} file(s)`,
      data: {
        files,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasMore: page * limit < total,
        },
      },
    };
  }

  /**
   * æœå°‹æ¨™ç±¤
   */
  async searchTags(params: {
    query: string;
    page: number;
    limit: number;
  }) {
    const { query, page, limit } = params;
    const skip = (page - 1) * limit;

    const where = {
      OR: [
        { name: { contains: query, mode: 'insensitive' as const } },
        { slug: { contains: query, mode: 'insensitive' as const } },
        { description: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    const [tags, total] = await Promise.all([
      this.prisma.tag.findMany({
        where,
        orderBy: { postsCount: 'desc' },  // æŒ‰ä½¿ç”¨æ¬¡æ•¸æ’åº
        skip,
        take: limit,
      }),
      this.prisma.tag.count({ where }),
    ]);

    return {
      success: true,
      message: `Found ${total} tag(s)`,
      data: {
        tags,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasMore: page * limit < total,
        },
      },
    };
  }

  /**
   * ç²å–æœå°‹å»ºè­°
   */
  async getSuggestions(query: string) {
    // ç²å–åŒ¹é…çš„æ¨™ç±¤ï¼ˆå‰ 5 å€‹ï¼‰
    const tags = await this.prisma.tag.findMany({
      where: {
        name: { contains: query, mode: 'insensitive' },
      },
      select: { name: true, postsCount: true },
      orderBy: { postsCount: 'desc' },
      take: 5,
    });

    // ç²å–åŒ¹é…çš„ç”¨æˆ¶ï¼ˆå‰ 3 å€‹ï¼‰
    const users = await this.prisma.user.findMany({
      where: {
        OR: [
          { username: { contains: query, mode: 'insensitive' } },
          { name: { contains: query, mode: 'insensitive' } },
        ],
      },
      select: { username: true, name: true, avatar: true },
      take: 3,
    });

    return {
      success: true,
      data: {
        tags: tags.map((t) => ({ text: t.name, type: 'tag', count: t.postsCount })),
        users: users.map((u) => ({
          text: u.name || u.username,
          type: 'user',
          avatar: u.avatar,
        })),
      },
    };
  }

  /**
   * ä¿å­˜æœå°‹æ­·å²
   */
  async saveSearchHistory(userId: string, query: string, type: string) {
    try {
      await this.prisma.searchHistory.create({
        data: {
          userId,
          query,
          type,
        },
      });
    } catch (error) {
      // å¿½ç•¥éŒ¯èª¤ï¼Œæœå°‹æ­·å²ä¸æ˜¯é—œéµåŠŸèƒ½
      console.error('Failed to save search history:', error);
    }
  }

  /**
   * ç²å–æœå°‹æ­·å²
   */
  async getSearchHistory(userId: string) {
    const history = await this.prisma.searchHistory.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      take: 10,
      select: {
        query: true,
        type: true,
        createdAt: true,
      },
    });

    return {
      success: true,
      data: { history },
    };
  }
}
```

### 4.3 TagsControllerï¼ˆHashtag ç®¡ç†ï¼‰

```typescript
// backend/src/tags/tags.controller.ts

import { Controller, Get, Post, Delete, Param, Body, Query, UseGuards, Request } from '@nestjs/common';
import { TagsService } from './tags.service';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';

@Controller('tags')
export class TagsController {
  constructor(private readonly tagsService: TagsService) {}

  /**
   * ç²å–æ‰€æœ‰æ¨™ç±¤
   */
  @Get()
  async getTags(
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    return this.tagsService.getTags({
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 20,
    });
  }

  /**
   * ç²å–ç†±é–€æ¨™ç±¤
   */
  @Get('popular')
  async getPopularTags(@Query('limit') limit?: string) {
    return this.tagsService.getPopularTags(parseInt(limit) || 10);
  }

  /**
   * ç²å–æ¨™ç±¤è©³æƒ…
   */
  @Get(':slug')
  async getTag(@Param('slug') slug: string) {
    return this.tagsService.getTag(slug);
  }

  /**
   * ç²å–æ¨™ç±¤ä¸‹çš„æ–‡ç« 
   */
  @Get(':slug/posts')
  async getTagPosts(
    @Param('slug') slug: string,
    @Query('page') page?: string,
    @Query('limit') limit?: string,
    @Query('sort') sort?: 'latest' | 'popular',
  ) {
    return this.tagsService.getTagPosts({
      slug,
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
      sort: sort || 'latest',
    });
  }
}

/**
 * Posts Tags Controllerï¼ˆæ–‡ç« æ¨™ç±¤ç®¡ç†ï¼‰
 */
@Controller('posts')
export class PostsTagsController {
  constructor(private readonly tagsService: TagsService) {}

  /**
   * ç‚ºæ–‡ç« æ·»åŠ æ¨™ç±¤
   */
  @UseGuards(JwtAuthGuard)
  @Post(':id/tags')
  async addPostTags(
    @Param('id') postId: string,
    @Body('tags') tags: string[],  // æ¨™ç±¤åç¨±æ•¸çµ„
    @Request() req,
  ) {
    return this.tagsService.addPostTags(postId, tags, req.user.id);
  }

  /**
   * ç§»é™¤æ–‡ç« æ¨™ç±¤
   */
  @UseGuards(JwtAuthGuard)
  @Delete(':id/tags/:tagId')
  async removePostTag(
    @Param('id') postId: string,
    @Param('tagId') tagId: string,
    @Request() req,
  ) {
    return this.tagsService.removePostTag(postId, tagId, req.user.id);
  }
}
```

### 4.4 TagsService

```typescript
// backend/src/tags/tags.service.ts

import { Injectable, NotFoundException, ForbiddenException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class TagsService {
  constructor(private prisma: PrismaService) {}

  /**
   * å‰µå»ºæˆ–ç²å–æ¨™ç±¤ï¼ˆå…§éƒ¨ä½¿ç”¨ï¼‰
   */
  private async createOrGetTag(name: string) {
    const slug = name.toLowerCase().replace(/\s+/g, '-');
    
    // å˜—è©¦ç²å–ç¾æœ‰æ¨™ç±¤
    let tag = await this.prisma.tag.findUnique({
      where: { slug },
    });

    // å¦‚æœä¸å­˜åœ¨ï¼Œå‰µå»ºæ–°æ¨™ç±¤
    if (!tag) {
      tag = await this.prisma.tag.create({
        data: {
          name,
          slug,
        },
      });
    }

    return tag;
  }

  /**
   * ç‚ºæ–‡ç« æ·»åŠ æ¨™ç±¤
   */
  async addPostTags(postId: string, tagNames: string[], userId: string) {
    // é©—è­‰æ–‡ç« æ‰€æœ‰æ¬Š
    const post = await this.prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      throw new NotFoundException('Post not found');
    }

    if (post.authorId !== userId) {
      throw new ForbiddenException('Not authorized');
    }

    // å‰µå»ºæˆ–ç²å–æ¨™ç±¤
    const tags = await Promise.all(
      tagNames.map((name) => this.createOrGetTag(name))
    );

    // é—œè¯æ¨™ç±¤åˆ°æ–‡ç« 
    await Promise.all(
      tags.map((tag) =>
        this.prisma.postTag.upsert({
          where: {
            postId_tagId: {
              postId,
              tagId: tag.id,
            },
          },
          create: {
            postId,
            tagId: tag.id,
          },
          update: {},
        })
      )
    );

    // æ›´æ–°æ¨™ç±¤çš„æ–‡ç« è¨ˆæ•¸
    await Promise.all(
      tags.map((tag) =>
        this.prisma.tag.update({
          where: { id: tag.id },
          data: {
            postsCount: {
              increment: 1,
            },
          },
        })
      )
    );

    return {
      success: true,
      message: 'Tags added successfully',
      data: { tags },
    };
  }

  /**
   * ç§»é™¤æ–‡ç« æ¨™ç±¤
   */
  async removePostTag(postId: string, tagId: string, userId: string) {
    // é©—è­‰æ–‡ç« æ‰€æœ‰æ¬Š
    const post = await this.prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      throw new NotFoundException('Post not found');
    }

    if (post.authorId !== userId) {
      throw new ForbiddenException('Not authorized');
    }

    // ç§»é™¤é—œè¯
    await this.prisma.postTag.delete({
      where: {
        postId_tagId: {
          postId,
          tagId,
        },
      },
    });

    // æ›´æ–°æ¨™ç±¤çš„æ–‡ç« è¨ˆæ•¸
    await this.prisma.tag.update({
      where: { id: tagId },
      data: {
        postsCount: {
          decrement: 1,
        },
      },
    });

    return {
      success: true,
      message: 'Tag removed successfully',
    };
  }

  /**
   * ç²å–æ‰€æœ‰æ¨™ç±¤
   */
  async getTags(params: { page: number; limit: number }) {
    const { page, limit } = params;
    const skip = (page - 1) * limit;

    const [tags, total] = await Promise.all([
      this.prisma.tag.findMany({
        orderBy: [
          { postsCount: 'desc' },
          { name: 'asc' },
        ],
        skip,
        take: limit,
      }),
      this.prisma.tag.count(),
    ]);

    return {
      success: true,
      data: {
        tags,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
        },
      },
    };
  }

  /**
   * ç²å–ç†±é–€æ¨™ç±¤
   */
  async getPopularTags(limit: number) {
    const tags = await this.prisma.tag.findMany({
      orderBy: { postsCount: 'desc' },
      take: limit,
    });

    return {
      success: true,
      data: { tags },
    };
  }

  /**
   * ç²å–æ¨™ç±¤è©³æƒ…
   */
  async getTag(slug: string) {
    const tag = await this.prisma.tag.findUnique({
      where: { slug },
    });

    if (!tag) {
      throw new NotFoundException('Tag not found');
    }

    return {
      success: true,
      data: { tag },
    };
  }

  /**
   * ç²å–æ¨™ç±¤ä¸‹çš„æ–‡ç« 
   */
  async getTagPosts(params: {
    slug: string;
    page: number;
    limit: number;
    sort: 'latest' | 'popular';
  }) {
    const { slug, page, limit, sort } = params;
    const skip = (page - 1) * limit;

    // ç²å–æ¨™ç±¤
    const tag = await this.prisma.tag.findUnique({
      where: { slug },
    });

    if (!tag) {
      throw new NotFoundException('Tag not found');
    }

    // æ’åºé‚è¼¯
    let orderBy: any = { createdAt: 'desc' };
    if (sort === 'popular') {
      orderBy = [
        { likesCount: 'desc' },
        { commentsCount: 'desc' },
      ];
    }

    const [postTags, total] = await Promise.all([
      this.prisma.postTag.findMany({
        where: {
          tagId: tag.id,
          post: { isPublished: true },
        },
        include: {
          post: {
            include: {
              author: {
                select: {
                  id: true,
                  username: true,
                  name: true,
                  avatar: true,
                },
              },
              postTags: {
                include: { tag: true },
              },
            },
          },
        },
        skip,
        take: limit,
      }),
      this.prisma.postTag.count({
        where: {
          tagId: tag.id,
          post: { isPublished: true },
        },
      }),
    ]);

    const posts = postTags.map((pt) => pt.post);

    return {
      success: true,
      data: {
        tag,
        posts,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
        },
      },
    };
  }
}
```

---

## 5. å‰ç«¯å¯¦ç¾

### 5.1 æœå°‹é¡å‹å®šç¾©

```typescript
// frontend/src/types/search.ts

export type SearchType = 'all' | 'posts' | 'users' | 'files' | 'tags';

export interface SearchParams {
  query: string;
  type?: SearchType;
  sort?: 'relevant' | 'latest' | 'popular' | 'followers' | 'posts';
  page?: number;
  limit?: number;
}

export interface SearchResult {
  posts?: Post[];
  users?: User[];
  files?: Attachment[];
  tags?: Tag[];
  pagination?: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasMore: boolean;
  };
}

export interface Tag {
  id: string;
  name: string;
  slug: string;
  description?: string;
  postsCount: number;
  createdAt: string;
}

export interface Attachment {
  id: string;
  filename: string;
  originalName: string;
  url: string;
  mimeType: string;
  size: number;
  createdAt: string;
  post: {
    id: string;
    title: string;
  };
  uploader: {
    id: string;
    username: string;
    name: string;
  };
}

export interface SearchSuggestion {
  text: string;
  type: 'tag' | 'user';
  avatar?: string;
  count?: number;
}
```

### 5.2 æœå°‹æœå‹™

```typescript
// frontend/src/services/search.service.ts

import { apiClient } from './api.client';
import { SearchParams, SearchResult, SearchSuggestion } from '../types/search';

export const searchService = {
  /**
   * ç¶œåˆæœå°‹
   */
  async search(params: SearchParams): Promise<SearchResult> {
    const response = await apiClient.get('/search', { params });
    return response.data;
  },

  /**
   * æœå°‹æ–‡ç« 
   */
  async searchPosts(params: Omit<SearchParams, 'type'>) {
    const response = await apiClient.get('/search/posts', { params });
    return response.data;
  },

  /**
   * æœå°‹ç”¨æˆ¶
   */
  async searchUsers(params: Omit<SearchParams, 'type'>) {
    const response = await apiClient.get('/search/users', { params });
    return response.data;
  },

  /**
   * æœå°‹æ–‡ä»¶
   */
  async searchFiles(params: Omit<SearchParams, 'type'>) {
    const response = await apiClient.get('/search/files', { params });
    return response.data;
  },

  /**
   * æœå°‹æ¨™ç±¤
   */
  async searchTags(params: Omit<SearchParams, 'type'>) {
    const response = await apiClient.get('/search/tags', { params });
    return response.data;
  },

  /**
   * ç²å–æœå°‹å»ºè­°
   */
  async getSuggestions(query: string): Promise<SearchSuggestion[]> {
    if (query.length < 2) return [];
    const response = await apiClient.get('/search/suggestions', {
      params: { q: query },
    });
    return [...response.data.tags, ...response.data.users];
  },

  /**
   * ç²å–æœå°‹æ­·å²
   */
  async getHistory() {
    const response = await apiClient.get('/search/history');
    return response.data.history;
  },
};
```

### 5.3 æ¨™ç±¤æœå‹™

```typescript
// frontend/src/services/tags.service.ts

import { apiClient } from './api.client';
import { Tag } from '../types/search';

export const tagsService = {
  /**
   * ç²å–æ‰€æœ‰æ¨™ç±¤
   */
  async getTags(params: { page?: number; limit?: number } = {}) {
    const response = await apiClient.get('/tags', { params });
    return response.data;
  },

  /**
   * ç²å–ç†±é–€æ¨™ç±¤
   */
  async getPopularTags(limit: number = 10) {
    const response = await apiClient.get('/tags/popular', {
      params: { limit },
    });
    return response.data.tags as Tag[];
  },

  /**
   * ç²å–æ¨™ç±¤è©³æƒ…
   */
  async getTag(slug: string) {
    const response = await apiClient.get(`/tags/${slug}`);
    return response.data.tag as Tag;
  },

  /**
   * ç²å–æ¨™ç±¤ä¸‹çš„æ–‡ç« 
   */
  async getTagPosts(params: {
    slug: string;
    page?: number;
    limit?: number;
    sort?: 'latest' | 'popular';
  }) {
    const { slug, ...queryParams } = params;
    const response = await apiClient.get(`/tags/${slug}/posts`, {
      params: queryParams,
    });
    return response.data;
  },

  /**
   * ç‚ºæ–‡ç« æ·»åŠ æ¨™ç±¤
   */
  async addPostTags(postId: string, tags: string[]) {
    const response = await apiClient.post(`/posts/${postId}/tags`, { tags });
    return response.data;
  },

  /**
   * ç§»é™¤æ–‡ç« æ¨™ç±¤
   */
  async removePostTag(postId: string, tagId: string) {
    const response = await apiClient.delete(`/posts/${postId}/tags/${tagId}`);
    return response.data;
  },
};
```

---

## 6. å‰ç«¯ UI å¯¦ç¾

### 6.1 çµ±ä¸€æœå°‹é é¢

```typescript
// frontend/src/screens/SearchScreen.tsx

import React, { useState, useEffect } from 'react';
import { View, FlatList, StyleSheet } from 'react-native';
import {
  Searchbar,
  SegmentedButtons,
  Chip,
  Text,
  Card,
  Avatar,
  IconButton,
  List,
} from 'react-native-paper';
import { searchService } from '../services/search.service';
import { SearchType } from '../types/search';
import PostCard from '../components/common/PostCard';
import UserCard from '../components/common/UserCard';
import FileCard from '../components/common/FileCard';
import TagChip from '../components/common/TagChip';

export default function SearchScreen({ navigation }: any) {
  const [query, setQuery] = useState('');
  const [searchType, setSearchType] = useState<SearchType>('all');
  const [results, setResults] = useState<any>({});
  const [loading, setLoading] = useState(false);
  const [suggestions, setSuggestions] = useState<any[]>([]);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [searchHistory, setSearchHistory] = useState<string[]>([]);

  // è¼‰å…¥æœå°‹æ­·å²
  useEffect(() => {
    loadSearchHistory();
  }, []);

  // ç²å–æœå°‹å»ºè­°
  useEffect(() => {
    const timer = setTimeout(async () => {
      if (query.length >= 2) {
        const data = await searchService.getSuggestions(query);
        setSuggestions(data);
        setShowSuggestions(true);
      } else {
        setSuggestions([]);
        setShowSuggestions(false);
      }
    }, 300); // é˜²æŠ–

    return () => clearTimeout(timer);
  }, [query]);

  const loadSearchHistory = async () => {
    try {
      const history = await searchService.getHistory();
      setSearchHistory(history.map((h: any) => h.query));
    } catch (error) {
      console.error('Load history error:', error);
    }
  };

  const handleSearch = async () => {
    if (!query.trim()) return;

    setLoading(true);
    setShowSuggestions(false);

    try {
      const data = await searchService.search({
        query,
        type: searchType,
      });

      setResults(data);
    } catch (error) {
      console.error('Search error:', error);
    } finally {
      setLoading(false);
    }
  };

  const renderSearchResults = () => {
    if (searchType === 'all') {
      return (
        <View>
          {results.posts?.length > 0 && (
            <View style={styles.section}>
              <Text variant="titleMedium" style={styles.sectionTitle}>
                æ–‡ç« 
              </Text>
              {results.posts.map((post: any) => (
                <PostCard key={post.id} post={post} />
              ))}
            </View>
          )}

          {results.users?.length > 0 && (
            <View style={styles.section}>
              <Text variant="titleMedium" style={styles.sectionTitle}>
                ç”¨æˆ¶
              </Text>
              {results.users.map((user: any) => (
                <UserCard key={user.id} user={user} />
              ))}
            </View>
          )}

          {results.files?.length > 0 && (
            <View style={styles.section}>
              <Text variant="titleMedium" style={styles.sectionTitle}>
                æ–‡ä»¶
              </Text>
              {results.files.map((file: any) => (
                <FileCard key={file.id} file={file} />
              ))}
            </View>
          )}

          {results.tags?.length > 0 && (
            <View style={styles.section}>
              <Text variant="titleMedium" style={styles.sectionTitle}>
                æ¨™ç±¤
              </Text>
              <View style={styles.tagsContainer}>
                {results.tags.map((tag: any) => (
                  <TagChip
                    key={tag.id}
                    tag={tag}
                    onPress={() => navigation.navigate('TagPosts', { slug: tag.slug })}
                  />
                ))}
              </View>
            </View>
          )}
        </View>
      );
    }

    // å–®ä¸€é¡å‹æœå°‹çµæœ
    const data = results[searchType] || [];
    return (
      <FlatList
        data={data}
        renderItem={({ item }) => {
          if (searchType === 'posts') return <PostCard post={item} />;
          if (searchType === 'users') return <UserCard user={item} />;
          if (searchType === 'files') return <FileCard file={item} />;
          if (searchType === 'tags') {
            return (
              <TagChip
                tag={item}
                onPress={() => navigation.navigate('TagPosts', { slug: item.slug })}
              />
            );
          }
          return null;
        }}
        keyExtractor={(item) => item.id}
      />
    );
  };

  return (
    <View style={styles.container}>
      {/* æœå°‹æ¡† */}
      <Searchbar
        placeholder="æœå°‹æ–‡ç« ã€ç”¨æˆ¶ã€æ–‡ä»¶ã€æ¨™ç±¤..."
        value={query}
        onChangeText={setQuery}
        onSubmitEditing={handleSearch}
        icon="magnify"
      />

      {/* æœå°‹å»ºè­° */}
      {showSuggestions && suggestions.length > 0 && (
        <Card style={styles.suggestionsCard}>
          {suggestions.map((suggestion, index) => (
            <List.Item
              key={index}
              title={suggestion.text}
              left={(props) =>
                suggestion.type === 'tag' ? (
                  <List.Icon {...props} icon="pound" />
                ) : (
                  <Avatar.Image
                    {...props}
                    size={40}
                    source={{ uri: suggestion.avatar || 'https://via.placeholder.com/40' }}
                  />
                )
              }
              right={(props) =>
                suggestion.count ? (
                  <Text {...props} variant="bodySmall">
                    {suggestion.count} ç¯‡æ–‡ç« 
                  </Text>
                ) : null
              }
              onPress={() => {
                setQuery(suggestion.text);
                handleSearch();
              }}
            />
          ))}
        </Card>
      )}

      {/* æœå°‹é¡å‹é¸æ“‡ */}
      <SegmentedButtons
        value={searchType}
        onValueChange={(value) => setSearchType(value as SearchType)}
        buttons={[
          { value: 'all', label: 'å…¨éƒ¨' },
          { value: 'posts', label: 'æ–‡ç« ' },
          { value: 'users', label: 'ç”¨æˆ¶' },
          { value: 'files', label: 'æ–‡ä»¶' },
          { value: 'tags', label: 'æ¨™ç±¤' },
        ]}
        style={styles.segmentedButtons}
      />

      {/* æœå°‹æ­·å²ï¼ˆç•¶æ²’æœ‰è¼¸å…¥æ™‚é¡¯ç¤ºï¼‰*/}
      {!query && searchHistory.length > 0 && (
        <View style={styles.historyContainer}>
          <Text variant="titleSmall" style={styles.historyTitle}>
            æœ€è¿‘æœå°‹
          </Text>
          <View style={styles.historyChips}>
            {searchHistory.map((historyQuery, index) => (
              <Chip
                key={index}
                icon="history"
                onPress={() => {
                  setQuery(historyQuery);
                  handleSearch();
                }}
                style={styles.historyChip}
              >
                {historyQuery}
              </Chip>
            ))}
          </View>
        </View>
      )}

      {/* æœå°‹çµæœ */}
      {renderSearchResults()}

      {/* ç©ºç‹€æ…‹ */}
      {!loading && query && Object.keys(results).length === 0 && (
        <View style={styles.emptyState}>
          <Text>æ²’æœ‰æ‰¾åˆ°ç›¸é—œçµæœ</Text>
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  segmentedButtons: {
    marginVertical: 12,
  },
  section: {
    marginBottom: 24,
  },
  sectionTitle: {
    marginBottom: 12,
    fontWeight: 'bold',
  },
  tagsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  suggestionsCard: {
    marginTop: 8,
    marginBottom: 8,
  },
  historyContainer: {
    marginVertical: 16,
  },
  historyTitle: {
    marginBottom: 8,
    opacity: 0.7,
  },
  historyChips: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  historyChip: {
    marginBottom: 8,
  },
  emptyState: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});
```

### 6.2 æ¨™ç±¤æ–‡ç« é é¢

```typescript
// frontend/src/screens/TagPostsScreen.tsx

import React, { useEffect, useState } from 'react';
import { View, FlatList, StyleSheet } from 'react-native';
import { Text, Chip, Appbar } from 'react-native-paper';
import { tagsService } from '../services/tags.service';
import PostCard from '../components/common/PostCard';

export default function TagPostsScreen({ route, navigation }: any) {
  const { slug } = route.params;
  const [tag, setTag] = useState<any>(null);
  const [posts, setPosts] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadTagPosts();
  }, [slug]);

  const loadTagPosts = async () => {
    try {
      const data = await tagsService.getTagPosts({ slug });
      setTag(data.tag);
      setPosts(data.posts);
    } catch (error) {
      console.error('Load tag posts error:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={styles.container}>
      <Appbar.Header>
        <Appbar.BackAction onPress={() => navigation.goBack()} />
        <Appbar.Content title={`#${tag?.name}`} />
      </Appbar.Header>

      {tag && (
        <View style={styles.header}>
          <Text variant="headlineMedium">#{tag.name}</Text>
          {tag.description && (
            <Text variant="bodyMedium" style={styles.description}>
              {tag.description}
            </Text>
          )}
          <Chip icon="file-document" style={styles.chip}>
            {tag.postsCount} ç¯‡æ–‡ç« 
          </Chip>
        </View>
      )}

      <FlatList
        data={posts}
        renderItem={({ item }) => <PostCard post={item} />}
        keyExtractor={(item) => item.id}
        refreshing={loading}
        onRefresh={loadTagPosts}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  description: {
    marginTop: 8,
    opacity: 0.7,
  },
  chip: {
    marginTop: 12,
    alignSelf: 'flex-start',
  },
});
```

---

## 7. æ•¸æ“šåº«é·ç§»

### 7.1 å‰µå»ºé·ç§»

```bash
# å‰µå»ºé·ç§»
npx prisma migrate dev --name add_search_features

# ç”Ÿæˆ Prisma Client
npx prisma generate
```

### 7.2 æ•¸æ“šå¡«å……ï¼ˆæ¸¬è©¦æ•¸æ“šï¼‰

```typescript
// prisma/seed-search.ts

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function seedTags() {
  console.log('Seeding tags...');

  const tags = [
    { name: 'æ—…éŠ', slug: 'travel', description: 'åˆ†äº«æ—…éŠç¶“æ­·å’Œæ™¯é»' },
    { name: 'ç¾é£Ÿ', slug: 'food', description: 'ç¾é£Ÿæ¨è–¦å’Œçƒ¹é£ªåˆ†äº«' },
    { name: 'ç§‘æŠ€', slug: 'tech', description: 'ç§‘æŠ€æ–°èå’Œç”¢å“è©•æ¸¬' },
    { name: 'ç”Ÿæ´»', slug: 'lifestyle', description: 'æ—¥å¸¸ç”Ÿæ´»åˆ†äº«' },
    { name: 'æ”å½±', slug: 'photography', description: 'æ”å½±ä½œå“å’ŒæŠ€å·§' },
    { name: 'é‹å‹•', slug: 'sports', description: 'é‹å‹•å¥èº«ç›¸é—œ' },
    { name: 'éŸ³æ¨‚', slug: 'music', description: 'éŸ³æ¨‚æ¨è–¦å’Œåˆ†äº«' },
    { name: 'é›»å½±', slug: 'movies', description: 'é›»å½±è©•è«–å’Œæ¨è–¦' },
  ];

  for (const tagData of tags) {
    await prisma.tag.upsert({
      where: { slug: tagData.slug },
      update: {},
      create: tagData,
    });
  }

  console.log(`Created ${tags.length} tags`);
}

async function seedPostTags() {
  console.log('Assigning tags to posts...');

  const posts = await prisma.post.findMany();
  const tags = await prisma.tag.findMany();

  for (const post of posts) {
    // éš¨æ©Ÿåˆ†é… 1-3 å€‹æ¨™ç±¤
    const numTags = Math.floor(Math.random() * 3) + 1;
    const randomTags = tags
      .sort(() => 0.5 - Math.random())
      .slice(0, numTags);

    for (const tag of randomTags) {
      await prisma.postTag.upsert({
        where: {
          postId_tagId: {
            postId: post.id,
            tagId: tag.id,
          },
        },
        update: {},
        create: {
          postId: post.id,
          tagId: tag.id,
        },
      });

      // æ›´æ–°æ¨™ç±¤æ–‡ç« è¨ˆæ•¸
      await prisma.tag.update({
        where: { id: tag.id },
        data: {
          postsCount: {
            increment: 1,
          },
        },
      });
    }
  }

  console.log('Post tags assigned');
}

async function main() {
  await seedTags();
  await seedPostTags();
  console.log('Search features seeded successfully!');
}

main()
  .catch(console.error)
  .finally(() => prisma.$disconnect());
```

---

## 8. å¯¦æ–½è¨ˆåŠƒ

### 8.1 é–‹ç™¼éšæ®µ

| éšæ®µ | ä»»å‹™ | æ™‚é–“ | å„ªå…ˆç´š |
|-----|------|------|--------|
| **éšæ®µ 1** | æ•¸æ“šæ¨¡å‹è¨­è¨ˆå’Œé·ç§» | 0.5 å¤© | â­â­â­â­â­ |
| - | å‰µå»º Attachmentã€Tagã€PostTagã€SearchHistory æ¨¡å‹ | | |
| - | åŸ·è¡Œæ•¸æ“šåº«é·ç§» | | |
| - | æ·»åŠ å¿…è¦çš„ç´¢å¼• | | |
| **éšæ®µ 2** | å¾Œç«¯ API å¯¦ç¾ | 2-3 å¤© | â­â­â­â­â­ |
| - | SearchController + SearchService | | |
| - | TagsController + TagsService | | |
| - | å¯¦ç¾æ‰€æœ‰æœå°‹ API | | |
| **éšæ®µ 3** | å‰ç«¯å¯¦ç¾ | 2-3 å¤© | â­â­â­â­â­ |
| - | æœå°‹æœå‹™å±¤ | | |
| - | çµ±ä¸€æœå°‹é é¢ UI | | |
| - | æ¨™ç±¤ç›¸é—œé é¢ | | |
| **éšæ®µ 4** | æ¸¬è©¦å’Œå„ªåŒ– | 1 å¤© | â­â­â­â­ |
| - | API æ¸¬è©¦ | | |
| - | ç”¨æˆ¶é«”é©—æ¸¬è©¦ | | |
| - | æ€§èƒ½å„ªåŒ– | | |

**ç¸½æ™‚é–“ï¼š6-8 å¤©** âœ…

---

## 9. æ¶æ§‹è¨­è¨ˆï¼šç‚º Elasticsearch åšæº–å‚™

### 9.1 æŠ½è±¡æœå°‹æ¥å£ï¼ˆé—œéµè¨­è¨ˆï¼‰

ç‚ºäº†å°‡ä¾†èƒ½ç„¡ç¸«åˆ‡æ›åˆ° Elasticsearchï¼Œæˆ‘å€‘æ¡ç”¨ **æ¥å£æŠ½è±¡** è¨­è¨ˆï¼š

```typescript
// backend/src/search/interfaces/search-engine.interface.ts

export interface ISearchEngine {
  // ç´¢å¼•æ“ä½œ
  indexPost(postId: string): Promise<void>;
  updatePost(postId: string): Promise<void>;
  deletePost(postId: string): Promise<void>;
  
  // æ‰¹é‡æ“ä½œ
  bulkIndexPosts(postIds: string[]): Promise<void>;
  
  // æœå°‹æ“ä½œ
  searchPosts(params: SearchParams): Promise<SearchResult>;
  searchUsers(params: SearchParams): Promise<SearchResult>;
  searchFiles(params: SearchParams): Promise<SearchResult>;
  searchTags(params: SearchParams): Promise<SearchResult>;
  
  // å»ºè­°å’Œçµ±è¨ˆ
  getSuggestions(query: string): Promise<Suggestion[]>;
}

export interface SearchParams {
  query: string;
  page: number;
  limit: number;
  sort?: string;
  filters?: Record<string, any>;
}

export interface SearchResult {
  items: any[];
  total: number;
  page: number;
  limit: number;
  hasMore: boolean;
}
```

### 9.2 PostgreSQL å¯¦ç¾ï¼ˆç•¶å‰ï¼‰

```typescript
// backend/src/search/engines/postgres-search.engine.ts

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { ISearchEngine, SearchParams, SearchResult } from '../interfaces/search-engine.interface';

@Injectable()
export class PostgresSearchEngine implements ISearchEngine {
  constructor(private prisma: PrismaService) {}

  // ç´¢å¼•æ“ä½œï¼ˆPostgreSQL ä¸­é€™äº›æ˜¯ç©ºæ“ä½œï¼Œå› ç‚ºæ•¸æ“šå·²åœ¨æ•¸æ“šåº«ä¸­ï¼‰
  async indexPost(postId: string): Promise<void> {
    // PostgreSQL ä¸éœ€è¦é¡¯å¼ç´¢å¼•ï¼Œä½†ä¿ç•™æ¥å£ä»¥ä¾¿å°‡ä¾†é·ç§»
    console.log(`[PostgreSQL] Post ${postId} already in database`);
  }

  async updatePost(postId: string): Promise<void> {
    // PostgreSQL é€šé Prisma è‡ªå‹•æ›´æ–°
    console.log(`[PostgreSQL] Post ${postId} updated in database`);
  }

  async deletePost(postId: string): Promise<void> {
    // PostgreSQL é€šé Prisma è‡ªå‹•åˆªé™¤
    console.log(`[PostgreSQL] Post ${postId} deleted from database`);
  }

  async bulkIndexPosts(postIds: string[]): Promise<void> {
    console.log(`[PostgreSQL] Bulk indexing ${postIds.length} posts`);
  }

  // æœå°‹å¯¦ç¾
  async searchPosts(params: SearchParams): Promise<SearchResult> {
    const { query, page, limit, sort } = params;
    const skip = (page - 1) * limit;

    const where = {
      isPublished: true,
      OR: [
        { title: { contains: query, mode: 'insensitive' as const } },
        { content: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    let orderBy: any = { createdAt: 'desc' };
    if (sort === 'popular') {
      orderBy = [
        { likesCount: 'desc' },
        { commentsCount: 'desc' },
      ];
    }

    const [items, total] = await Promise.all([
      this.prisma.post.findMany({
        where,
        include: {
          author: {
            select: {
              id: true,
              username: true,
              name: true,
              avatar: true,
            },
          },
          postTags: {
            include: { tag: true },
          },
        },
        orderBy,
        skip,
        take: limit,
      }),
      this.prisma.post.count({ where }),
    ]);

    return {
      items,
      total,
      page,
      limit,
      hasMore: page * limit < total,
    };
  }

  async searchUsers(params: SearchParams): Promise<SearchResult> {
    const { query, page, limit, sort } = params;
    const skip = (page - 1) * limit;

    const where = {
      OR: [
        { username: { contains: query, mode: 'insensitive' as const } },
        { name: { contains: query, mode: 'insensitive' as const } },
        { bio: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    let orderBy: any = { followersCount: 'desc' };
    if (sort === 'posts') {
      orderBy = { postsCount: 'desc' };
    }

    const [items, total] = await Promise.all([
      this.prisma.user.findMany({
        where,
        select: {
          id: true,
          username: true,
          name: true,
          bio: true,
          avatar: true,
          location: true,
          followersCount: true,
          followingCount: true,
          postsCount: true,
        },
        orderBy,
        skip,
        take: limit,
      }),
      this.prisma.user.count({ where }),
    ]);

    return {
      items,
      total,
      page,
      limit,
      hasMore: page * limit < total,
    };
  }

  async searchFiles(params: SearchParams): Promise<SearchResult> {
    const { query, page, limit } = params;
    const skip = (page - 1) * limit;

    const where = {
      OR: [
        { filename: { contains: query, mode: 'insensitive' as const } },
        { originalName: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    const [items, total] = await Promise.all([
      this.prisma.attachment.findMany({
        where,
        include: {
          post: { select: { id: true, title: true } },
          uploader: { select: { id: true, username: true, name: true } },
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit,
      }),
      this.prisma.attachment.count({ where }),
    ]);

    return {
      items,
      total,
      page,
      limit,
      hasMore: page * limit < total,
    };
  }

  async searchTags(params: SearchParams): Promise<SearchResult> {
    const { query, page, limit } = params;
    const skip = (page - 1) * limit;

    const where = {
      OR: [
        { name: { contains: query, mode: 'insensitive' as const } },
        { slug: { contains: query, mode: 'insensitive' as const } },
        { description: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    const [items, total] = await Promise.all([
      this.prisma.tag.findMany({
        where,
        orderBy: { postsCount: 'desc' },
        skip,
        take: limit,
      }),
      this.prisma.tag.count({ where }),
    ]);

    return {
      items,
      total,
      page,
      limit,
      hasMore: page * limit < total,
    };
  }

  async getSuggestions(query: string): Promise<any[]> {
    const [tags, users] = await Promise.all([
      this.prisma.tag.findMany({
        where: { name: { contains: query, mode: 'insensitive' } },
        select: { name: true, postsCount: true },
        orderBy: { postsCount: 'desc' },
        take: 5,
      }),
      this.prisma.user.findMany({
        where: {
          OR: [
            { username: { contains: query, mode: 'insensitive' } },
            { name: { contains: query, mode: 'insensitive' } },
          ],
        },
        select: { username: true, name: true, avatar: true },
        take: 3,
      }),
    ]);

    return [
      ...tags.map((t) => ({ text: t.name, type: 'tag', count: t.postsCount })),
      ...users.map((u) => ({ text: u.name || u.username, type: 'user', avatar: u.avatar })),
    ];
  }
}
```

### 9.3 Elasticsearch å¯¦ç¾ï¼ˆæœªä¾†ï¼‰

```typescript
// backend/src/search/engines/elasticsearch.engine.ts
// é€™æ˜¯å°‡ä¾†é·ç§»æ™‚çš„å¯¦ç¾ç¤ºä¾‹ï¼Œç¾åœ¨ä¸éœ€è¦å®‰è£

import { Injectable } from '@nestjs/common';
import { Client } from '@elastic/elasticsearch';
import { PrismaService } from '../../prisma/prisma.service';
import { ISearchEngine, SearchParams, SearchResult } from '../interfaces/search-engine.interface';

@Injectable()
export class ElasticsearchEngine implements ISearchEngine {
  private client: Client;
  
  constructor(private prisma: PrismaService) {
    // å°‡ä¾†å•Ÿç”¨æ™‚å–æ¶ˆè¨»é‡‹
    // this.client = new Client({
    //   node: process.env.ELASTICSEARCH_URL || 'http://localhost:9200',
    // });
  }

  async indexPost(postId: string): Promise<void> {
    const post = await this.prisma.post.findUnique({
      where: { id: postId },
      include: {
        author: { select: { id: true, name: true, username: true } },
        postTags: { include: { tag: true } },
      },
    });

    if (!post) return;

    await this.client.index({
      index: 'posts',
      id: post.id,
      document: {
        id: post.id,
        title: post.title,
        content: post.content,
        authorId: post.authorId,
        authorName: post.author.name || post.author.username,
        tags: post.postTags.map(pt => pt.tag.name),
        createdAt: post.createdAt,
        likesCount: post.likesCount,
        commentsCount: post.commentsCount,
      },
    });
  }

  async updatePost(postId: string): Promise<void> {
    await this.indexPost(postId); // é‡æ–°ç´¢å¼•å³æ˜¯æ›´æ–°
  }

  async deletePost(postId: string): Promise<void> {
    await this.client.delete({
      index: 'posts',
      id: postId,
    });
  }

  async bulkIndexPosts(postIds: string[]): Promise<void> {
    const operations = postIds.flatMap(id => [
      { index: { _index: 'posts', _id: id } },
      { id }, // æ–‡æª”æ•¸æ“šå°‡åœ¨ç´¢å¼•æ™‚ç²å–
    ]);

    await this.client.bulk({ operations });
  }

  async searchPosts(params: SearchParams): Promise<SearchResult> {
    const { query, page, limit, sort } = params;
    const from = (page - 1) * limit;

    const result = await this.client.search({
      index: 'posts',
      body: {
        from,
        size: limit,
        query: {
          multi_match: {
            query,
            fields: ['title^3', 'content', 'authorName^2'],
            fuzziness: 'AUTO',
          },
        },
        sort: sort === 'popular' 
          ? [{ likesCount: 'desc' }, { commentsCount: 'desc' }]
          : [{ _score: 'desc' }, { createdAt: 'desc' }],
      },
    });

    return {
      items: result.hits.hits.map(hit => hit._source),
      total: result.hits.total.value,
      page,
      limit,
      hasMore: page * limit < result.hits.total.value,
    };
  }

  // ... å…¶ä»–æ–¹æ³•é¡ä¼¼å¯¦ç¾
}
```

### 9.4 æœå°‹æœå‹™ï¼ˆä½¿ç”¨æŠ½è±¡æ¥å£ï¼‰

```typescript
// backend/src/search/search.service.ts

import { Injectable, Inject } from '@nestjs/common';
import { ISearchEngine } from './interfaces/search-engine.interface';

@Injectable()
export class SearchService {
  constructor(
    @Inject('SEARCH_ENGINE')
    private searchEngine: ISearchEngine,  // æ³¨å…¥æŠ½è±¡æ¥å£ï¼Œè€Œéå…·é«”å¯¦ç¾
  ) {}

  async search(params: {
    query: string;
    type: 'all' | 'posts' | 'users' | 'files' | 'tags';
    page: number;
    limit: number;
  }) {
    const { query, type, page, limit } = params;

    if (type === 'posts') {
      const result = await this.searchEngine.searchPosts({ query, page, limit });
      return {
        success: true,
        data: {
          posts: result.items,
          pagination: {
            page: result.page,
            limit: result.limit,
            total: result.total,
            hasMore: result.hasMore,
          },
        },
      };
    }

    if (type === 'users') {
      const result = await this.searchEngine.searchUsers({ query, page, limit });
      return {
        success: true,
        data: {
          users: result.items,
          pagination: {
            page: result.page,
            limit: result.limit,
            total: result.total,
            hasMore: result.hasMore,
          },
        },
      };
    }

    if (type === 'files') {
      const result = await this.searchEngine.searchFiles({ query, page, limit });
      return {
        success: true,
        data: {
          files: result.items,
          pagination: {
            page: result.page,
            limit: result.limit,
            total: result.total,
            hasMore: result.hasMore,
          },
        },
      };
    }

    if (type === 'tags') {
      const result = await this.searchEngine.searchTags({ query, page, limit });
      return {
        success: true,
        data: {
          tags: result.items,
          pagination: {
            page: result.page,
            limit: result.limit,
            total: result.total,
            hasMore: result.hasMore,
          },
        },
      };
    }

    // type === 'all'
    const [posts, users, files, tags] = await Promise.all([
      this.searchEngine.searchPosts({ query, page: 1, limit: 5 }),
      this.searchEngine.searchUsers({ query, page: 1, limit: 5 }),
      this.searchEngine.searchFiles({ query, page: 1, limit: 5 }),
      this.searchEngine.searchTags({ query, page: 1, limit: 5 }),
    ]);

    return {
      success: true,
      data: {
        posts: posts.items,
        users: users.items,
        files: files.items,
        tags: tags.items,
      },
    };
  }

  async getSuggestions(query: string) {
    const suggestions = await this.searchEngine.getSuggestions(query);
    return {
      success: true,
      data: { suggestions },
    };
  }
}
```

### 9.5 æ¨¡å¡Šé…ç½®ï¼ˆåˆ‡æ›å¼•æ“ï¼‰

```typescript
// backend/src/search/search.module.ts

import { Module } from '@nestjs/common';
import { SearchController } from './search.controller';
import { SearchService } from './search.service';
import { PostgresSearchEngine } from './engines/postgres-search.engine';
// import { ElasticsearchEngine } from './engines/elasticsearch.engine'; // æœªä¾†å•Ÿç”¨

@Module({
  controllers: [SearchController],
  providers: [
    SearchService,
    {
      provide: 'SEARCH_ENGINE',
      useClass: PostgresSearchEngine,  // ç•¶å‰ä½¿ç”¨ PostgreSQL
      // useClass: ElasticsearchEngine,  // å°‡ä¾†åˆ‡æ›åˆ° Elasticsearch åªéœ€æ”¹é€™ä¸€è¡Œ
    },
  ],
  exports: [SearchService],
})
export class SearchModule {}
```

### 9.6 ç’°å¢ƒè®Šæ•¸é…ç½®

```bash
# backend/.env

# æœå°‹å¼•æ“é…ç½®
SEARCH_ENGINE=postgres  # å¯é¸ï¼špostgres, elasticsearch

# Elasticsearch é…ç½®ï¼ˆæœªä¾†ä½¿ç”¨ï¼‰
# ELASTICSEARCH_URL=http://localhost:9200
# ELASTICSEARCH_USERNAME=elastic
# ELASTICSEARCH_PASSWORD=your_password
```

### 9.7 PostService é›†æˆï¼ˆæ”¯æŒä»»ä½•æœå°‹å¼•æ“ï¼‰

```typescript
// backend/src/posts/posts.service.ts

import { Injectable, Inject } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { ISearchEngine } from '../search/interfaces/search-engine.interface';

@Injectable()
export class PostsService {
  constructor(
    private prisma: PrismaService,
    @Inject('SEARCH_ENGINE')
    private searchEngine: ISearchEngine,  // æ³¨å…¥æœå°‹å¼•æ“æ¥å£
  ) {}

  async createPost(data: CreatePostDto, userId: string) {
    const post = await this.prisma.post.create({
      data: {
        ...data,
        authorId: userId,
      },
    });

    // è‡ªå‹•ç´¢å¼•ï¼ˆPostgreSQL æ˜¯ç©ºæ“ä½œï¼ŒElasticsearch æœƒçœŸæ­£ç´¢å¼•ï¼‰
    await this.searchEngine.indexPost(post.id);

    return post;
  }

  async updatePost(postId: string, data: UpdatePostDto, userId: string) {
    const post = await this.prisma.post.update({
      where: { id: postId, authorId: userId },
      data,
    });

    // æ›´æ–°ç´¢å¼•
    await this.searchEngine.updatePost(post.id);

    return post;
  }

  async deletePost(postId: string, userId: string) {
    await this.prisma.post.delete({
      where: { id: postId, authorId: userId },
    });

    // åˆªé™¤ç´¢å¼•
    await this.searchEngine.deletePost(postId);

    return { success: true };
  }
}
```

---

## 9.8 é·ç§»åˆ° Elasticsearch çš„æ­¥é©Ÿï¼ˆæœªä¾†ï¼‰

ç•¶éœ€è¦é·ç§»æ™‚ï¼Œåªéœ€è¦ï¼š

**æ­¥é©Ÿ 1ï¼šå®‰è£ä¾è³´**
```bash
npm install @elastic/elasticsearch
```

**æ­¥é©Ÿ 2ï¼šå•Ÿå‹• Elasticsearch**
```bash
# ä½¿ç”¨ Docker
docker run -d \
  --name elasticsearch \
  -p 9200:9200 \
  -e "discovery.type=single-node" \
  -e "xpack.security.enabled=false" \
  docker.elastic.co/elasticsearch/elasticsearch:8.11.0
```

**æ­¥é©Ÿ 3ï¼šä¿®æ”¹é…ç½®**
```typescript
// backend/src/search/search.module.ts
{
  provide: 'SEARCH_ENGINE',
  useClass: ElasticsearchEngine,  // æ”¹é€™ä¸€è¡Œ
}
```

**æ­¥é©Ÿ 4ï¼šåˆå§‹åŒ–ç´¢å¼•**
```bash
# åŸ·è¡Œé·ç§»è…³æœ¬ï¼ˆæ‰¹é‡ç´¢å¼•ç¾æœ‰æ•¸æ“šï¼‰
npm run search:reindex
```

**å®Œæˆï¼** å‰ç«¯ä»£ç¢¼ç„¡éœ€ä»»ä½•ä¿®æ”¹ã€‚

---

## 9.9 æ€§èƒ½å„ªåŒ–

### æ•¸æ“šåº«ç´¢å¼•ï¼ˆPostgreSQLï¼‰
```sql
-- æ–‡ç« æœå°‹
CREATE INDEX idx_posts_title_search ON posts(title);
CREATE INDEX idx_posts_content_search ON posts USING gin(to_tsvector('simple', content));

-- ç”¨æˆ¶æœå°‹
CREATE INDEX idx_users_username_search ON users(username);
CREATE INDEX idx_users_name_search ON users(name);

-- æ¨™ç±¤æœå°‹
CREATE INDEX idx_tags_name_search ON tags(name);
CREATE INDEX idx_tags_slug_search ON tags(slug);

-- æ–‡ä»¶æœå°‹
CREATE INDEX idx_attachments_filename_search ON attachments(filename);
CREATE INDEX idx_attachments_original_name_search ON attachments(original_name);
```

### ç·©å­˜ç­–ç•¥
```typescript
// ç·©å­˜ç†±é–€æ¨™ç±¤
import { Redis } from 'ioredis';
const redis = new Redis();

async getPopularTags(limit: number) {
  const cacheKey = `tags:popular:${limit}`;
  const cached = await redis.get(cacheKey);
  
  if (cached) {
    return JSON.parse(cached);
  }
  
  const tags = await this.prisma.tag.findMany({
    orderBy: { postsCount: 'desc' },
    take: limit,
  });
  
  await redis.set(cacheKey, JSON.stringify(tags), 'EX', 3600); // 1 å°æ™‚
  return tags;
}
```

---

## 10. ç¸½çµ

### 10.1 å®Œæ•´åŠŸèƒ½æ¸…å–®

âœ… **æ–‡ç« æœå°‹**
- æ¨™é¡Œå’Œå…§å®¹æœå°‹
- å¤šç¨®æ’åºï¼ˆæœ€æ–°ã€ç†±é–€ï¼‰
- åˆ†é æ”¯æŒ

âœ… **ç”¨æˆ¶æœå°‹**
- ç”¨æˆ¶åã€åç¨±ã€ç°¡ä»‹æœå°‹
- æŒ‰ç²‰çµ²æ•¸æˆ–ç™¼æ–‡æ•¸æ’åº
- ç”¨æˆ¶å¡ç‰‡å±•ç¤º

âœ… **æ–‡ä»¶æœå°‹**
- æ–‡ä»¶åç¨±æ¨¡ç³Šæœå°‹
- æ–‡ä»¶é¡å‹è­˜åˆ¥
- é—œè¯æ–‡ç« é¡¯ç¤º

âœ… **Hashtag æœå°‹**
- æ¨™ç±¤åç¨±æœå°‹
- æ¨™ç±¤è©³æƒ…é é¢
- æ¨™ç±¤ä¸‹æ–‡ç« åˆ—è¡¨
- æ–‡ç« æ¨™ç±¤ç®¡ç†

âœ… **é€²éšåŠŸèƒ½**
- çµ±ä¸€æœå°‹ç•Œé¢
- æœå°‹å»ºè­°ï¼ˆè‡ªå‹•å®Œæˆï¼‰
- æœå°‹æ­·å²
- åˆ†é¡ç¯©é¸

### 10.2 æŠ€è¡“äº®é»

1. **çµ±ä¸€ API è¨­è¨ˆ**ï¼šä¸€è‡´çš„æ¥å£é¢¨æ ¼
2. **æ¨¡ç³Šæœå°‹**ï¼šPostgreSQL ILIKE æ”¯æŒ
3. **æ€§èƒ½å„ªåŒ–**ï¼šé©ç•¶çš„ç´¢å¼•å’Œç·©å­˜
4. **ç”¨æˆ¶é«”é©—**ï¼šæœå°‹å»ºè­°å’Œæ­·å²è¨˜éŒ„
5. **å¯æ“´å±•æ€§**ï¼šæ˜“æ–¼æ·»åŠ æ–°çš„æœå°‹é¡å‹

### 10.3 å¯¦æ–½å»ºè­°

**æ¨è–¦ç«‹å³å¯¦æ–½ï¼š** âœ…
- éœ€æ±‚æ˜ç¢ºï¼ˆæ–‡ç« ã€ç”¨æˆ¶ã€æ–‡ä»¶ã€æ¨™ç±¤ï¼‰
- é–‹ç™¼æ™‚é–“åˆç†ï¼ˆ6-8 å¤©ï¼‰
- æŠ€è¡“æ–¹æ¡ˆæˆç†Ÿ
- ç”¨æˆ¶åƒ¹å€¼é«˜

---

**æ–‡æª”ç‰ˆæœ¬ï¼š** v1.0  
**å‰µå»ºæ—¥æœŸï¼š** 2025-10-29  
**ä½œè€…ï¼š** HAPPY SHARE é–‹ç™¼åœ˜éšŠ  
**ç‹€æ…‹ï¼š** âœ… æ¨è–¦å¯¦æ–½  
**é è¨ˆæ™‚é–“ï¼š** 6-8 å¤©  
**å„ªå…ˆç´šï¼š** â­â­â­â­â­ é«˜
