# 多媒體搜尋功能分析與擴展方案

## 1. 需求概述

### 1.1 核心需求
在搜尋功能中支持搜尋用戶在文章中上傳的：
- 📷 **圖片** (Images)
- 🎬 **視頻** (Videos)
- 📄 **文件** (Files/Documents)

### 1.2 使用場景
- 用戶想找到包含特定圖片的文章
- 用戶想搜尋某個視頻
- 用戶想找到分享過某類型文件的文章
- 按媒體類型篩選內容（只看視頻文章、只看圖片文章）

---

## 2. 當前狀態分析

### 2.1 現有數據模型
```prisma
model Post {
  id              String    @id @default(uuid())
  title           String
  content         String    @db.Text
  image           String?   // ❌ 只支持單一圖片 URL
  // ... 其他欄位
}
```

**問題：**
- ❌ 只支持單一圖片
- ❌ 不支持視頻
- ❌ 不支持文件附件
- ❌ 無法記錄媒體元數據（文件名、大小、類型）

### 2.2 需要的改進
1. **支持多媒體內容**：一篇文章可以有多個圖片、視頻、文件
2. **元數據記錄**：文件名、類型、大小、描述
3. **媒體管理**：獨立的媒體表，可複用和管理
4. **搜尋支持**：按文件名、類型、描述搜尋

---

## 3. 數據模型設計方案

### 3.1 方案 A：獨立媒體表（推薦）⭐⭐⭐⭐⭐

**優點：**
- ✅ 結構清晰，易於管理
- ✅ 支持媒體複用
- ✅ 易於擴展（添加新媒體類型）
- ✅ 便於統計和搜尋
- ✅ 可以獨立管理媒體（刪除、編輯）

**缺點：**
- ⚠️ 查詢需要 JOIN
- ⚠️ 稍微複雜一些

#### 新增 Prisma Schema

```prisma
// 媒體類型枚舉
enum MediaType {
  IMAGE       // 圖片
  VIDEO       // 視頻
  DOCUMENT    // 文檔（PDF, Word, Excel 等）
  AUDIO       // 音頻（可選）
  OTHER       // 其他
}

// 媒體模型
model Media {
  id           String     @id @default(uuid())
  type         MediaType  // 媒體類型
  url          String     // 存儲 URL（CDN 或本地路徑）
  filename     String     // 原始文件名
  mimeType     String     // MIME 類型（image/jpeg, video/mp4 等）
  size         Int        // 文件大小（bytes）
  width        Int?       // 圖片/視頻寬度
  height       Int?       // 圖片/視頻高度
  duration     Int?       // 視頻/音頻時長（秒）
  thumbnail    String?    // 縮略圖 URL（用於視頻）
  description  String?    // 媒體描述（可搜尋）
  alt          String?    // Alt 文字（用於圖片無障礙）
  
  postId       String     // 所屬文章
  uploaderId   String     // 上傳者
  
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  
  // 關聯
  post         Post       @relation(fields: [postId], references: [id], onDelete: Cascade)
  uploader     User       @relation(fields: [uploaderId], references: [id], onDelete: Cascade)
  
  @@index([postId])
  @@index([uploaderId])
  @@index([type])
  @@index([filename])       // 用於文件名搜尋
  @@index([description])    // 用於描述搜尋
  @@index([createdAt])
  @@map("media")
}

// 更新 Post 模型
model Post {
  id              String    @id @default(uuid())
  title           String
  content         String    @db.Text
  // image 欄位可以保留作為主圖（向後兼容），或移除
  coverImage      String?   // 封面圖（可選，用於列表展示）
  
  // ... 其他欄位不變 ...
  
  // 新增關聯
  media           Media[]   // 一篇文章可以有多個媒體
  
  @@map("posts")
}

// 更新 User 模型
model User {
  // ... 現有欄位 ...
  
  // 新增關聯
  uploadedMedia   Media[]   // 用戶上傳的媒體
  
  @@map("users")
}
```

---

### 3.2 方案 B：JSON 欄位存儲（簡單但限制多）⭐⭐⭐

**優點：**
- ✅ 實現簡單快速
- ✅ 無需新建表
- ✅ 查詢不需要 JOIN

**缺點：**
- ❌ 不易搜尋（需要 JSON 查詢）
- ❌ 不易統計
- ❌ 難以維護
- ❌ 無法獨立管理媒體

#### Schema 設計

```prisma
model Post {
  id              String    @id @default(uuid())
  title           String
  content         String    @db.Text
  
  // 使用 JSON 存儲多媒體
  media           Json?     // { images: [...], videos: [...], files: [...] }
  
  // ... 其他欄位 ...
}
```

**不推薦原因：**JSON 查詢在 PostgreSQL 中性能較差，不適合搜尋場景。

---

### 3.3 推薦方案：方案 A（獨立媒體表）

採用獨立媒體表是業界標準做法，例如：
- WordPress 的 `wp_posts` (attachments)
- Instagram 的媒體管理系統
- Twitter 的媒體服務

---

## 4. 搜尋功能實現

### 4.1 擴展的搜尋類型

#### 4.1.1 按媒體類型搜尋
```typescript
// 搜尋包含視頻的文章
GET /api/search/posts?q=keyword&mediaType=VIDEO

// 搜尋包含圖片的文章
GET /api/search/posts?q=keyword&mediaType=IMAGE

// 搜尋包含文檔的文章
GET /api/search/posts?q=keyword&mediaType=DOCUMENT
```

#### 4.1.2 直接搜尋媒體
```typescript
// 搜尋媒體（按文件名）
GET /api/search/media?q=filename&type=IMAGE

// 搜尋媒體（按描述）
GET /api/search/media?q=description&type=VIDEO
```

#### 4.1.3 組合搜尋
```typescript
// 搜尋標題或內容包含關鍵字，且包含視頻的文章
GET /api/search/posts?q=keyword&hasMedia=true&mediaType=VIDEO
```

---

### 4.2 後端實現示例

#### 4.2.1 SearchService 擴展

```typescript
// backend/src/search/search.service.ts

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { MediaType } from '@prisma/client';

@Injectable()
export class SearchService {
  constructor(private prisma: PrismaService) {}

  /**
   * 搜尋文章（支持媒體類型篩選）
   */
  async searchPosts(params: {
    query: string;
    mediaType?: MediaType;      // 按媒體類型篩選
    hasMedia?: boolean;          // 只搜尋有媒體的文章
    authorId?: string;
    sort?: 'latest' | 'popular' | 'relevant';
    page: number;
    limit: number;
  }) {
    const { query, mediaType, hasMedia, authorId, sort, page, limit } = params;
    const skip = (page - 1) * limit;

    // 構建基礎條件
    const where: any = {
      isPublished: true,
      ...(authorId && { authorId }),
      OR: [
        { title: { contains: query, mode: 'insensitive' } },
        { content: { contains: query, mode: 'insensitive' } },
      ],
    };

    // 添加媒體相關條件
    if (hasMedia || mediaType) {
      where.media = {
        some: {
          ...(mediaType && { type: mediaType }),
        },
      };
    }

    // 排序邏輯
    let orderBy: any = { createdAt: 'desc' };
    if (sort === 'popular') {
      orderBy = [
        { likesCount: 'desc' },
        { commentsCount: 'desc' },
      ];
    }

    const [posts, total] = await Promise.all([
      this.prisma.post.findMany({
        where,
        include: {
          author: {
            select: {
              id: true,
              username: true,
              name: true,
              avatar: true,
            },
          },
          media: true,  // 包含所有媒體
        },
        orderBy,
        skip,
        take: limit,
      }),
      this.prisma.post.count({ where }),
    ]);

    return {
      success: true,
      message: 'Posts retrieved successfully',
      data: {
        posts,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasMore: page * limit < total,
        },
      },
    };
  }

  /**
   * 直接搜尋媒體
   */
  async searchMedia(params: {
    query: string;
    type?: MediaType;
    page: number;
    limit: number;
  }) {
    const { query, type, page, limit } = params;
    const skip = (page - 1) * limit;

    const where = {
      ...(type && { type }),
      OR: [
        { filename: { contains: query, mode: 'insensitive' } },
        { description: { contains: query, mode: 'insensitive' } },
        { alt: { contains: query, mode: 'insensitive' } },
      ],
    };

    const [media, total] = await Promise.all([
      this.prisma.media.findMany({
        where,
        include: {
          post: {
            select: {
              id: true,
              title: true,
            },
          },
          uploader: {
            select: {
              id: true,
              username: true,
              name: true,
              avatar: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit,
      }),
      this.prisma.media.count({ where }),
    ]);

    return {
      success: true,
      message: 'Media retrieved successfully',
      data: {
        media,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasMore: page * limit < total,
        },
      },
    };
  }

  /**
   * 按媒體類型統計
   */
  async getMediaStats(userId?: string) {
    const where = userId ? { uploaderId: userId } : {};

    const stats = await this.prisma.media.groupBy({
      by: ['type'],
      where,
      _count: true,
      _sum: {
        size: true,
      },
    });

    return {
      success: true,
      message: 'Media stats retrieved successfully',
      data: stats.map(stat => ({
        type: stat.type,
        count: stat._count,
        totalSize: stat._sum.size || 0,
      })),
    };
  }
}
```

#### 4.2.2 SearchController 擴展

```typescript
// backend/src/search/search.controller.ts

import { Controller, Get, Query, UseGuards, Request } from '@nestjs/common';
import { SearchService } from './search.service';
import { MediaType } from '@prisma/client';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';

@Controller('search')
export class SearchController {
  constructor(private readonly searchService: SearchService) {}

  // 搜尋文章（支持媒體篩選）
  @Get('posts')
  async searchPosts(
    @Query('q') query: string,
    @Query('mediaType') mediaType?: MediaType,
    @Query('hasMedia') hasMedia?: string,
    @Query('author') authorId?: string,
    @Query('sort') sort?: 'latest' | 'popular' | 'relevant',
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    return this.searchService.searchPosts({
      query,
      mediaType,
      hasMedia: hasMedia === 'true',
      authorId,
      sort: sort || 'relevant',
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }

  // 搜尋媒體
  @Get('media')
  async searchMedia(
    @Query('q') query: string,
    @Query('type') type?: MediaType,
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    return this.searchService.searchMedia({
      query,
      type,
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }

  // 獲取媒體統計
  @UseGuards(JwtAuthGuard)
  @Get('media/stats')
  async getMediaStats(@Request() req) {
    return this.searchService.getMediaStats(req.user.id);
  }
}
```

---

### 4.3 前端實現示例

#### 4.3.1 擴展搜尋服務

```typescript
// frontend/src/services/search.service.ts

export enum MediaType {
  IMAGE = 'IMAGE',
  VIDEO = 'VIDEO',
  DOCUMENT = 'DOCUMENT',
  AUDIO = 'AUDIO',
  OTHER = 'OTHER',
}

export const searchService = {
  /**
   * 搜尋文章（支持媒體篩選）
   */
  async searchPosts(params: {
    query: string;
    mediaType?: MediaType;
    hasMedia?: boolean;
    author?: string;
    sort?: 'latest' | 'popular' | 'relevant';
    page?: number;
    limit?: number;
  }) {
    const response = await apiClient.get('/search/posts', { params });
    return response.data;
  },

  /**
   * 搜尋媒體
   */
  async searchMedia(params: {
    query: string;
    type?: MediaType;
    page?: number;
    limit?: number;
  }) {
    const response = await apiClient.get('/search/media', { params });
    return response.data;
  },

  /**
   * 獲取媒體統計
   */
  async getMediaStats() {
    const response = await apiClient.get('/search/media/stats');
    return response.data;
  },
};
```

#### 4.3.2 搜尋頁面 UI

```typescript
// frontend/src/screens/SearchScreen.tsx

import React, { useState } from 'react';
import { View, ScrollView } from 'react-native';
import { Searchbar, Chip, SegmentedButtons } from 'react-native-paper';
import { MediaType } from '../services/search.service';

export default function SearchScreen() {
  const [query, setQuery] = useState('');
  const [searchType, setSearchType] = useState<'posts' | 'media'>('posts');
  const [mediaType, setMediaType] = useState<MediaType | null>(null);
  const [results, setResults] = useState([]);

  const mediaTypeOptions = [
    { value: null, label: '全部', icon: 'all-inclusive' },
    { value: MediaType.IMAGE, label: '圖片', icon: 'image' },
    { value: MediaType.VIDEO, label: '視頻', icon: 'video' },
    { value: MediaType.DOCUMENT, label: '文檔', icon: 'file-document' },
  ];

  const handleSearch = async () => {
    if (!query.trim()) return;
    
    try {
      if (searchType === 'posts') {
        const data = await searchService.searchPosts({
          query,
          mediaType: mediaType || undefined,
          hasMedia: mediaType ? true : undefined,
        });
        setResults(data.posts);
      } else {
        const data = await searchService.searchMedia({
          query,
          type: mediaType || undefined,
        });
        setResults(data.media);
      }
    } catch (error) {
      console.error('Search error:', error);
    }
  };

  return (
    <View style={{ flex: 1, padding: 16 }}>
      {/* 搜尋框 */}
      <Searchbar
        placeholder="搜尋文章、圖片、視頻..."
        value={query}
        onChangeText={setQuery}
        onSubmitEditing={handleSearch}
      />

      {/* 搜尋類型選擇 */}
      <SegmentedButtons
        value={searchType}
        onValueChange={setSearchType}
        buttons={[
          { value: 'posts', label: '文章' },
          { value: 'media', label: '媒體' },
        ]}
        style={{ marginVertical: 12 }}
      />

      {/* 媒體類型篩選 */}
      <ScrollView horizontal showsHorizontalScrollIndicator={false}>
        <View style={{ flexDirection: 'row', gap: 8 }}>
          {mediaTypeOptions.map((option) => (
            <Chip
              key={option.label}
              selected={mediaType === option.value}
              onPress={() => setMediaType(option.value)}
              icon={option.icon}
            >
              {option.label}
            </Chip>
          ))}
        </View>
      </ScrollView>

      {/* 搜尋結果 */}
      <SearchResults results={results} type={searchType} />
    </View>
  );
}
```

---

## 5. 文件上傳功能實現

### 5.1 後端文件上傳

#### 5.1.1 安裝依賴

```bash
npm install --save @nestjs/platform-express multer
npm install --save-dev @types/multer
```

#### 5.1.2 MediaController

```typescript
// backend/src/media/media.controller.ts

import {
  Controller,
  Post,
  UploadedFile,
  UseInterceptors,
  UseGuards,
  Request,
  Body,
  BadRequestException,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';
import { MediaService } from './media.service';
import { diskStorage } from 'multer';
import { extname } from 'path';

@Controller('media')
export class MediaController {
  constructor(private readonly mediaService: MediaService) {}

  @UseGuards(JwtAuthGuard)
  @Post('upload')
  @UseInterceptors(
    FileInterceptor('file', {
      storage: diskStorage({
        destination: './uploads',
        filename: (req, file, cb) => {
          const randomName = Array(32)
            .fill(null)
            .map(() => Math.round(Math.random() * 16).toString(16))
            .join('');
          cb(null, `${randomName}${extname(file.originalname)}`);
        },
      }),
      limits: {
        fileSize: 50 * 1024 * 1024, // 50MB
      },
      fileFilter: (req, file, cb) => {
        // 允許的文件類型
        const allowedMimes = [
          'image/jpeg',
          'image/png',
          'image/gif',
          'image/webp',
          'video/mp4',
          'video/webm',
          'application/pdf',
          'application/msword',
          'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        ];
        
        if (allowedMimes.includes(file.mimetype)) {
          cb(null, true);
        } else {
          cb(new BadRequestException('File type not allowed'), false);
        }
      },
    }),
  )
  async uploadFile(
    @UploadedFile() file: Express.Multer.File,
    @Body('postId') postId: string,
    @Body('description') description?: string,
    @Body('alt') alt?: string,
    @Request() req?,
  ) {
    if (!file) {
      throw new BadRequestException('No file uploaded');
    }

    return this.mediaService.createMedia({
      file,
      postId,
      uploaderId: req.user.id,
      description,
      alt,
    });
  }
}
```

#### 5.1.3 MediaService

```typescript
// backend/src/media/media.service.ts

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { MediaType } from '@prisma/client';

@Injectable()
export class MediaService {
  constructor(private prisma: PrismaService) {}

  async createMedia(params: {
    file: Express.Multer.File;
    postId: string;
    uploaderId: string;
    description?: string;
    alt?: string;
  }) {
    const { file, postId, uploaderId, description, alt } = params;

    // 判斷媒體類型
    const type = this.getMediaType(file.mimetype);

    // 獲取圖片/視頻尺寸（可選，需要額外的庫）
    // const dimensions = await this.getMediaDimensions(file.path, type);

    const media = await this.prisma.media.create({
      data: {
        type,
        url: `/uploads/${file.filename}`,
        filename: file.originalname,
        mimeType: file.mimetype,
        size: file.size,
        description,
        alt,
        postId,
        uploaderId,
      },
    });

    return {
      success: true,
      message: 'Media uploaded successfully',
      data: media,
    };
  }

  private getMediaType(mimeType: string): MediaType {
    if (mimeType.startsWith('image/')) return MediaType.IMAGE;
    if (mimeType.startsWith('video/')) return MediaType.VIDEO;
    if (mimeType.includes('pdf') || mimeType.includes('document')) {
      return MediaType.DOCUMENT;
    }
    return MediaType.OTHER;
  }
}
```

---

## 6. 實施計劃

### 6.1 階段劃分

#### 階段 0：數據模型遷移（必須先完成）
**時間：1-2 天**

1. 創建 Media 模型的 Prisma schema
2. 執行數據庫遷移
3. 更新現有文章的圖片數據（遷移腳本）

```bash
# 創建遷移
npx prisma migrate dev --name add_media_model

# 執行數據遷移腳本（將現有的 Post.image 遷移到 Media 表）
npx ts-node prisma/migrate-images.ts
```

---

#### 階段 1：基礎媒體管理（2-3 天）

1. 實現文件上傳 API
   - MediaController + MediaService
   - 文件驗證和存儲
   - 支持圖片、視頻、文檔

2. 更新文章創建/編輯 API
   - 支持添加多個媒體
   - 媒體與文章關聯

3. 前端媒體上傳組件
   - 圖片上傳
   - 視頻上傳
   - 文件上傳
   - 上傳進度顯示

---

#### 階段 2：媒體搜尋功能（2-3 天）

1. 實現媒體搜尋 API
   - 按文件名搜尋
   - 按媒體類型篩選
   - 按描述搜尋

2. 擴展文章搜尋 API
   - 支持按媒體類型篩選
   - 搜尋包含特定媒體的文章

3. 前端搜尋界面
   - 媒體類型篩選器
   - 媒體搜尋結果展示
   - 媒體預覽

---

#### 階段 3：進階功能（可選，3-5 天）

1. 媒體管理
   - 用戶媒體庫
   - 批量上傳
   - 媒體編輯和刪除

2. 圖片處理
   - 自動生成縮略圖
   - 圖片壓縮
   - 尺寸調整

3. 視頻處理
   - 視頻縮略圖生成
   - 視頻轉碼（可選）
   - 視頻播放器

---

### 6.2 總時間估算

| 階段 | 時間 | 優先級 |
|-----|------|--------|
| 階段 0：數據模型遷移 | 1-2 天 | ⭐⭐⭐⭐⭐ 必須 |
| 階段 1：基礎媒體管理 | 2-3 天 | ⭐⭐⭐⭐⭐ 必須 |
| 階段 2：媒體搜尋功能 | 2-3 天 | ⭐⭐⭐⭐ 重要 |
| 階段 3：進階功能 | 3-5 天 | ⭐⭐⭐ 可選 |

**最小可行產品（MVP）：** 階段 0 + 階段 1 = 3-5 天  
**完整搜尋功能：** 階段 0 + 1 + 2 = 5-8 天  
**完整功能：** 所有階段 = 8-13 天

---

## 7. 技術挑戰與解決方案

### 7.1 文件存儲

#### 挑戰
- 本地存儲容量限制
- 文件訪問速度
- 備份和恢復

#### 解決方案

**方案 A：本地存儲（開發/小規模）**
```typescript
// 簡單但有限制
storage: diskStorage({
  destination: './uploads',
  filename: (req, file, cb) => {
    // 生成唯一文件名
  },
})
```

**方案 B：雲端存儲（推薦用於生產）**
- AWS S3
- Google Cloud Storage
- Cloudflare R2（性價比高）
- Backblaze B2（便宜）

```typescript
// 使用 AWS S3 示例
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

const s3Client = new S3Client({ region: 'us-east-1' });

async uploadToS3(file: Express.Multer.File) {
  const command = new PutObjectCommand({
    Bucket: 'your-bucket',
    Key: `uploads/${Date.now()}-${file.originalname}`,
    Body: file.buffer,
    ContentType: file.mimetype,
  });
  
  await s3Client.send(command);
}
```

---

### 7.2 圖片/視頻處理

#### 挑戰
- 圖片需要壓縮和生成縮略圖
- 視頻需要生成預覽圖
- 處理耗時可能影響用戶體驗

#### 解決方案

**方案 A：使用 Sharp（圖片處理）**
```typescript
import sharp from 'sharp';

async processImage(inputPath: string) {
  // 生成縮略圖
  await sharp(inputPath)
    .resize(300, 300, { fit: 'cover' })
    .toFile(`${inputPath}-thumb.jpg`);
    
  // 壓縮原圖
  await sharp(inputPath)
    .jpeg({ quality: 80 })
    .toFile(`${inputPath}-optimized.jpg`);
}
```

**方案 B：使用 FFmpeg（視頻處理）**
```typescript
import ffmpeg from 'fluent-ffmpeg';

async generateVideoThumbnail(videoPath: string) {
  return new Promise((resolve, reject) => {
    ffmpeg(videoPath)
      .screenshots({
        timestamps: ['00:00:01'],
        filename: 'thumbnail.jpg',
        folder: './thumbnails',
      })
      .on('end', resolve)
      .on('error', reject);
  });
}
```

**方案 C：後台任務隊列（推薦）**
```typescript
// 使用 Bull Queue 處理耗時任務
import { Queue } from 'bull';

const mediaProcessingQueue = new Queue('media-processing');

// 添加任務
await mediaProcessingQueue.add('process-image', {
  mediaId: media.id,
  path: media.url,
});

// 處理任務（worker）
mediaProcessingQueue.process('process-image', async (job) => {
  const { mediaId, path } = job.data;
  // 執行壓縮、生成縮略圖等
});
```

---

### 7.3 搜尋性能

#### 挑戰
- 多媒體搜尋可能涉及多表 JOIN
- 文件名和描述的全文搜尋

#### 解決方案

1. **數據庫索引**
```sql
-- 文件名索引
CREATE INDEX idx_media_filename ON media(filename);

-- 描述全文索引
CREATE INDEX idx_media_description_fts ON media USING gin(to_tsvector('english', description));

-- 復合索引
CREATE INDEX idx_media_type_created ON media(type, created_at DESC);
```

2. **查詢優化**
```typescript
// 使用 Prisma 的高效查詢
const posts = await prisma.post.findMany({
  where: {
    media: {
      some: { type: MediaType.VIDEO }
    }
  },
  include: {
    media: {
      where: { type: MediaType.VIDEO }  // 只載入視頻
    }
  }
});
```

3. **緩存**
```typescript
// 使用 Redis 緩存熱門搜尋結果
import { Redis } from 'ioredis';
const redis = new Redis();

const cacheKey = `search:${query}:${mediaType}`;
const cached = await redis.get(cacheKey);

if (cached) {
  return JSON.parse(cached);
}

// 執行搜尋...
await redis.set(cacheKey, JSON.stringify(results), 'EX', 300); // 5分鐘
```

---

## 8. 安全性考慮

### 8.1 文件驗證

```typescript
// 嚴格的文件類型檢查
const ALLOWED_MIME_TYPES = {
  IMAGE: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
  VIDEO: ['video/mp4', 'video/webm', 'video/quicktime'],
  DOCUMENT: ['application/pdf', 'application/msword', /* ... */],
};

// 文件大小限制
const MAX_FILE_SIZE = {
  IMAGE: 10 * 1024 * 1024,      // 10MB
  VIDEO: 100 * 1024 * 1024,     // 100MB
  DOCUMENT: 20 * 1024 * 1024,   // 20MB
};

// 文件內容驗證（防止偽裝）
import fileType from 'file-type';

const type = await fileType.fromBuffer(file.buffer);
if (type.mime !== file.mimetype) {
  throw new Error('File type mismatch');
}
```

### 8.2 訪問控制

```typescript
// 只有文章作者可以刪除媒體
async deleteMedia(mediaId: string, userId: string) {
  const media = await this.prisma.media.findUnique({
    where: { id: mediaId },
    include: { post: true },
  });
  
  if (media.post.authorId !== userId) {
    throw new ForbiddenException('Not authorized');
  }
  
  // 刪除文件和數據庫記錄
  await this.deleteFile(media.url);
  await this.prisma.media.delete({ where: { id: mediaId } });
}
```

### 8.3 防止濫用

```typescript
// 限制上傳頻率
import { Throttle } from '@nestjs/throttler';

@Throttle(10, 60)  // 每分鐘最多 10 次
@Post('upload')
async uploadFile() {
  // ...
}

// 限制用戶總存儲空間
async checkUserQuota(userId: string) {
  const totalSize = await this.prisma.media.aggregate({
    where: { uploaderId: userId },
    _sum: { size: true },
  });
  
  const MAX_QUOTA = 1024 * 1024 * 1024;  // 1GB
  if (totalSize._sum.size > MAX_QUOTA) {
    throw new BadRequestException('Storage quota exceeded');
  }
}
```

---

## 9. 成本分析

### 9.1 開發成本

| 項目 | 時間 | 複雜度 |
|-----|------|--------|
| 數據模型設計和遷移 | 1-2 天 | 🟡 中 |
| 文件上傳功能 | 2-3 天 | 🟡 中 |
| 媒體管理 API | 2-3 天 | 🟡 中 |
| 搜尋功能擴展 | 2-3 天 | 🟡 中 |
| 前端 UI 開發 | 3-4 天 | 🟡 中 |
| 圖片/視頻處理 | 2-3 天 | 🔴 高 |
| 測試和優化 | 2-3 天 | 🟡 中 |
| **總計** | **14-21 天** | - |

### 9.2 運營成本

**存儲成本（月）：**
- 本地存儲：$0（但有限制）
- AWS S3：$0.023/GB（標準存儲）
- Cloudflare R2：$0.015/GB（無出站流量費）
- Backblaze B2：$0.005/GB（最便宜）

**示例（1000 用戶，每人平均 100MB）：**
- 總存儲：100GB
- AWS S3：~$2.30/月
- Cloudflare R2：~$1.50/月
- Backblaze B2：~$0.50/月

**CDN 成本：**
- Cloudflare：免費（基礎）
- AWS CloudFront：$0.085/GB（流量）

---

## 10. 總結與建議

### 10.1 推薦實施路徑

```
第一階段（必須）：
1. 設計和實現 Media 數據模型
2. 基礎文件上傳功能（圖片優先）
3. 更新文章創建/編輯流程
   ↓
第二階段（重要）：
4. 擴展支持視頻和文檔
5. 實現媒體搜尋功能
6. 添加媒體類型篩選
   ↓
第三階段（優化）：
7. 圖片壓縮和縮略圖
8. 視頻處理和預覽
9. 媒體管理界面
```

### 10.2 關鍵建議

1. **先完成基礎文字搜尋**
   - 如果還沒實現基礎搜尋，建議先完成（參考 `搜尋功能分析評估.md`）
   - 媒體搜尋可以作為擴展功能

2. **優先支持圖片**
   - 圖片是最常用的媒體類型
   - 實現相對簡單
   - 用戶需求最高

3. **選擇合適的存儲方案**
   - 開發階段：本地存儲
   - 生產環境：雲端存儲（推薦 Cloudflare R2 或 Backblaze B2）

4. **性能優化**
   - 添加適當的數據庫索引
   - 使用 CDN 加速媒體訪問
   - 後台處理耗時任務

5. **安全第一**
   - 嚴格的文件類型驗證
   - 文件大小限制
   - 訪問權限控制
   - 防止濫用（限流、配額）

### 10.3 風險提示

⚠️ **高風險項目：**
- 存儲成本可能快速增長
- 視頻處理複雜且耗資源
- 需要完善的安全機制

🟡 **中風險項目：**
- 數據庫遷移可能影響現有數據
- 搜尋性能需要優化
- 前端 UI 開發工作量較大

### 10.4 是否現在實施？

**建議暫緩實施，優先完成：**
1. ✅ 核心功能穩定（發文、評論、點讚）
2. ✅ 基礎搜尋功能（文字搜尋）
3. ✅ 用戶量達到一定規模
4. ✅ 明確的用戶需求

**適合實施的時機：**
- 基礎功能已經穩定運行
- 用戶有明確的多媒體分享需求
- 團隊有充足的開發時間（2-3 週）
- 預算可以支持存儲和處理成本

---

**文檔版本：** v1.0  
**創建日期：** 2025-10-29  
**作者：** HAPPY SHARE 開發團隊  
**狀態：** 📋 規劃中 - 建議暫緩實施
