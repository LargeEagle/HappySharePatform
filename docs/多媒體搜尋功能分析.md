# å¤šåª’é«”æœå°‹åŠŸèƒ½åˆ†æèˆ‡æ“´å±•æ–¹æ¡ˆ

## 1. éœ€æ±‚æ¦‚è¿°

### 1.1 æ ¸å¿ƒéœ€æ±‚
åœ¨æœå°‹åŠŸèƒ½ä¸­æ”¯æŒæœå°‹ç”¨æˆ¶åœ¨æ–‡ç« ä¸­ä¸Šå‚³çš„ï¼š
- ğŸ“· **åœ–ç‰‡** (Images)
- ğŸ¬ **è¦–é »** (Videos)
- ğŸ“„ **æ–‡ä»¶** (Files/Documents)

### 1.2 ä½¿ç”¨å ´æ™¯
- ç”¨æˆ¶æƒ³æ‰¾åˆ°åŒ…å«ç‰¹å®šåœ–ç‰‡çš„æ–‡ç« 
- ç”¨æˆ¶æƒ³æœå°‹æŸå€‹è¦–é »
- ç”¨æˆ¶æƒ³æ‰¾åˆ°åˆ†äº«éæŸé¡å‹æ–‡ä»¶çš„æ–‡ç« 
- æŒ‰åª’é«”é¡å‹ç¯©é¸å…§å®¹ï¼ˆåªçœ‹è¦–é »æ–‡ç« ã€åªçœ‹åœ–ç‰‡æ–‡ç« ï¼‰

---

## 2. ç•¶å‰ç‹€æ…‹åˆ†æ

### 2.1 ç¾æœ‰æ•¸æ“šæ¨¡å‹
```prisma
model Post {
  id              String    @id @default(uuid())
  title           String
  content         String    @db.Text
  image           String?   // âŒ åªæ”¯æŒå–®ä¸€åœ–ç‰‡ URL
  // ... å…¶ä»–æ¬„ä½
}
```

**å•é¡Œï¼š**
- âŒ åªæ”¯æŒå–®ä¸€åœ–ç‰‡
- âŒ ä¸æ”¯æŒè¦–é »
- âŒ ä¸æ”¯æŒæ–‡ä»¶é™„ä»¶
- âŒ ç„¡æ³•è¨˜éŒ„åª’é«”å…ƒæ•¸æ“šï¼ˆæ–‡ä»¶åã€å¤§å°ã€é¡å‹ï¼‰

### 2.2 éœ€è¦çš„æ”¹é€²
1. **æ”¯æŒå¤šåª’é«”å…§å®¹**ï¼šä¸€ç¯‡æ–‡ç« å¯ä»¥æœ‰å¤šå€‹åœ–ç‰‡ã€è¦–é »ã€æ–‡ä»¶
2. **å…ƒæ•¸æ“šè¨˜éŒ„**ï¼šæ–‡ä»¶åã€é¡å‹ã€å¤§å°ã€æè¿°
3. **åª’é«”ç®¡ç†**ï¼šç¨ç«‹çš„åª’é«”è¡¨ï¼Œå¯è¤‡ç”¨å’Œç®¡ç†
4. **æœå°‹æ”¯æŒ**ï¼šæŒ‰æ–‡ä»¶åã€é¡å‹ã€æè¿°æœå°‹

---

## 3. æ•¸æ“šæ¨¡å‹è¨­è¨ˆæ–¹æ¡ˆ

### 3.1 æ–¹æ¡ˆ Aï¼šç¨ç«‹åª’é«”è¡¨ï¼ˆæ¨è–¦ï¼‰â­â­â­â­â­

**å„ªé»ï¼š**
- âœ… çµæ§‹æ¸…æ™°ï¼Œæ˜“æ–¼ç®¡ç†
- âœ… æ”¯æŒåª’é«”è¤‡ç”¨
- âœ… æ˜“æ–¼æ“´å±•ï¼ˆæ·»åŠ æ–°åª’é«”é¡å‹ï¼‰
- âœ… ä¾¿æ–¼çµ±è¨ˆå’Œæœå°‹
- âœ… å¯ä»¥ç¨ç«‹ç®¡ç†åª’é«”ï¼ˆåˆªé™¤ã€ç·¨è¼¯ï¼‰

**ç¼ºé»ï¼š**
- âš ï¸ æŸ¥è©¢éœ€è¦ JOIN
- âš ï¸ ç¨å¾®è¤‡é›œä¸€äº›

#### æ–°å¢ Prisma Schema

```prisma
// åª’é«”é¡å‹æšèˆ‰
enum MediaType {
  IMAGE       // åœ–ç‰‡
  VIDEO       // è¦–é »
  DOCUMENT    // æ–‡æª”ï¼ˆPDF, Word, Excel ç­‰ï¼‰
  AUDIO       // éŸ³é »ï¼ˆå¯é¸ï¼‰
  OTHER       // å…¶ä»–
}

// åª’é«”æ¨¡å‹
model Media {
  id           String     @id @default(uuid())
  type         MediaType  // åª’é«”é¡å‹
  url          String     // å­˜å„² URLï¼ˆCDN æˆ–æœ¬åœ°è·¯å¾‘ï¼‰
  filename     String     // åŸå§‹æ–‡ä»¶å
  mimeType     String     // MIME é¡å‹ï¼ˆimage/jpeg, video/mp4 ç­‰ï¼‰
  size         Int        // æ–‡ä»¶å¤§å°ï¼ˆbytesï¼‰
  width        Int?       // åœ–ç‰‡/è¦–é »å¯¬åº¦
  height       Int?       // åœ–ç‰‡/è¦–é »é«˜åº¦
  duration     Int?       // è¦–é »/éŸ³é »æ™‚é•·ï¼ˆç§’ï¼‰
  thumbnail    String?    // ç¸®ç•¥åœ– URLï¼ˆç”¨æ–¼è¦–é »ï¼‰
  description  String?    // åª’é«”æè¿°ï¼ˆå¯æœå°‹ï¼‰
  alt          String?    // Alt æ–‡å­—ï¼ˆç”¨æ–¼åœ–ç‰‡ç„¡éšœç¤™ï¼‰
  
  postId       String     // æ‰€å±¬æ–‡ç« 
  uploaderId   String     // ä¸Šå‚³è€…
  
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  
  // é—œè¯
  post         Post       @relation(fields: [postId], references: [id], onDelete: Cascade)
  uploader     User       @relation(fields: [uploaderId], references: [id], onDelete: Cascade)
  
  @@index([postId])
  @@index([uploaderId])
  @@index([type])
  @@index([filename])       // ç”¨æ–¼æ–‡ä»¶åæœå°‹
  @@index([description])    // ç”¨æ–¼æè¿°æœå°‹
  @@index([createdAt])
  @@map("media")
}

// æ›´æ–° Post æ¨¡å‹
model Post {
  id              String    @id @default(uuid())
  title           String
  content         String    @db.Text
  // image æ¬„ä½å¯ä»¥ä¿ç•™ä½œç‚ºä¸»åœ–ï¼ˆå‘å¾Œå…¼å®¹ï¼‰ï¼Œæˆ–ç§»é™¤
  coverImage      String?   // å°é¢åœ–ï¼ˆå¯é¸ï¼Œç”¨æ–¼åˆ—è¡¨å±•ç¤ºï¼‰
  
  // ... å…¶ä»–æ¬„ä½ä¸è®Š ...
  
  // æ–°å¢é—œè¯
  media           Media[]   // ä¸€ç¯‡æ–‡ç« å¯ä»¥æœ‰å¤šå€‹åª’é«”
  
  @@map("posts")
}

// æ›´æ–° User æ¨¡å‹
model User {
  // ... ç¾æœ‰æ¬„ä½ ...
  
  // æ–°å¢é—œè¯
  uploadedMedia   Media[]   // ç”¨æˆ¶ä¸Šå‚³çš„åª’é«”
  
  @@map("users")
}
```

---

### 3.2 æ–¹æ¡ˆ Bï¼šJSON æ¬„ä½å­˜å„²ï¼ˆç°¡å–®ä½†é™åˆ¶å¤šï¼‰â­â­â­

**å„ªé»ï¼š**
- âœ… å¯¦ç¾ç°¡å–®å¿«é€Ÿ
- âœ… ç„¡éœ€æ–°å»ºè¡¨
- âœ… æŸ¥è©¢ä¸éœ€è¦ JOIN

**ç¼ºé»ï¼š**
- âŒ ä¸æ˜“æœå°‹ï¼ˆéœ€è¦ JSON æŸ¥è©¢ï¼‰
- âŒ ä¸æ˜“çµ±è¨ˆ
- âŒ é›£ä»¥ç¶­è­·
- âŒ ç„¡æ³•ç¨ç«‹ç®¡ç†åª’é«”

#### Schema è¨­è¨ˆ

```prisma
model Post {
  id              String    @id @default(uuid())
  title           String
  content         String    @db.Text
  
  // ä½¿ç”¨ JSON å­˜å„²å¤šåª’é«”
  media           Json?     // { images: [...], videos: [...], files: [...] }
  
  // ... å…¶ä»–æ¬„ä½ ...
}
```

**ä¸æ¨è–¦åŸå› ï¼š**JSON æŸ¥è©¢åœ¨ PostgreSQL ä¸­æ€§èƒ½è¼ƒå·®ï¼Œä¸é©åˆæœå°‹å ´æ™¯ã€‚

---

### 3.3 æ¨è–¦æ–¹æ¡ˆï¼šæ–¹æ¡ˆ Aï¼ˆç¨ç«‹åª’é«”è¡¨ï¼‰

æ¡ç”¨ç¨ç«‹åª’é«”è¡¨æ˜¯æ¥­ç•Œæ¨™æº–åšæ³•ï¼Œä¾‹å¦‚ï¼š
- WordPress çš„ `wp_posts` (attachments)
- Instagram çš„åª’é«”ç®¡ç†ç³»çµ±
- Twitter çš„åª’é«”æœå‹™

---

## 4. æœå°‹åŠŸèƒ½å¯¦ç¾

### 4.1 æ“´å±•çš„æœå°‹é¡å‹

#### 4.1.1 æŒ‰åª’é«”é¡å‹æœå°‹
```typescript
// æœå°‹åŒ…å«è¦–é »çš„æ–‡ç« 
GET /api/search/posts?q=keyword&mediaType=VIDEO

// æœå°‹åŒ…å«åœ–ç‰‡çš„æ–‡ç« 
GET /api/search/posts?q=keyword&mediaType=IMAGE

// æœå°‹åŒ…å«æ–‡æª”çš„æ–‡ç« 
GET /api/search/posts?q=keyword&mediaType=DOCUMENT
```

#### 4.1.2 ç›´æ¥æœå°‹åª’é«”
```typescript
// æœå°‹åª’é«”ï¼ˆæŒ‰æ–‡ä»¶åï¼‰
GET /api/search/media?q=filename&type=IMAGE

// æœå°‹åª’é«”ï¼ˆæŒ‰æè¿°ï¼‰
GET /api/search/media?q=description&type=VIDEO
```

#### 4.1.3 çµ„åˆæœå°‹
```typescript
// æœå°‹æ¨™é¡Œæˆ–å…§å®¹åŒ…å«é—œéµå­—ï¼Œä¸”åŒ…å«è¦–é »çš„æ–‡ç« 
GET /api/search/posts?q=keyword&hasMedia=true&mediaType=VIDEO
```

---

### 4.2 å¾Œç«¯å¯¦ç¾ç¤ºä¾‹

#### 4.2.1 SearchService æ“´å±•

```typescript
// backend/src/search/search.service.ts

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { MediaType } from '@prisma/client';

@Injectable()
export class SearchService {
  constructor(private prisma: PrismaService) {}

  /**
   * æœå°‹æ–‡ç« ï¼ˆæ”¯æŒåª’é«”é¡å‹ç¯©é¸ï¼‰
   */
  async searchPosts(params: {
    query: string;
    mediaType?: MediaType;      // æŒ‰åª’é«”é¡å‹ç¯©é¸
    hasMedia?: boolean;          // åªæœå°‹æœ‰åª’é«”çš„æ–‡ç« 
    authorId?: string;
    sort?: 'latest' | 'popular' | 'relevant';
    page: number;
    limit: number;
  }) {
    const { query, mediaType, hasMedia, authorId, sort, page, limit } = params;
    const skip = (page - 1) * limit;

    // æ§‹å»ºåŸºç¤æ¢ä»¶
    const where: any = {
      isPublished: true,
      ...(authorId && { authorId }),
      OR: [
        { title: { contains: query, mode: 'insensitive' } },
        { content: { contains: query, mode: 'insensitive' } },
      ],
    };

    // æ·»åŠ åª’é«”ç›¸é—œæ¢ä»¶
    if (hasMedia || mediaType) {
      where.media = {
        some: {
          ...(mediaType && { type: mediaType }),
        },
      };
    }

    // æ’åºé‚è¼¯
    let orderBy: any = { createdAt: 'desc' };
    if (sort === 'popular') {
      orderBy = [
        { likesCount: 'desc' },
        { commentsCount: 'desc' },
      ];
    }

    const [posts, total] = await Promise.all([
      this.prisma.post.findMany({
        where,
        include: {
          author: {
            select: {
              id: true,
              username: true,
              name: true,
              avatar: true,
            },
          },
          media: true,  // åŒ…å«æ‰€æœ‰åª’é«”
        },
        orderBy,
        skip,
        take: limit,
      }),
      this.prisma.post.count({ where }),
    ]);

    return {
      success: true,
      message: 'Posts retrieved successfully',
      data: {
        posts,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasMore: page * limit < total,
        },
      },
    };
  }

  /**
   * ç›´æ¥æœå°‹åª’é«”
   */
  async searchMedia(params: {
    query: string;
    type?: MediaType;
    page: number;
    limit: number;
  }) {
    const { query, type, page, limit } = params;
    const skip = (page - 1) * limit;

    const where = {
      ...(type && { type }),
      OR: [
        { filename: { contains: query, mode: 'insensitive' } },
        { description: { contains: query, mode: 'insensitive' } },
        { alt: { contains: query, mode: 'insensitive' } },
      ],
    };

    const [media, total] = await Promise.all([
      this.prisma.media.findMany({
        where,
        include: {
          post: {
            select: {
              id: true,
              title: true,
            },
          },
          uploader: {
            select: {
              id: true,
              username: true,
              name: true,
              avatar: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit,
      }),
      this.prisma.media.count({ where }),
    ]);

    return {
      success: true,
      message: 'Media retrieved successfully',
      data: {
        media,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasMore: page * limit < total,
        },
      },
    };
  }

  /**
   * æŒ‰åª’é«”é¡å‹çµ±è¨ˆ
   */
  async getMediaStats(userId?: string) {
    const where = userId ? { uploaderId: userId } : {};

    const stats = await this.prisma.media.groupBy({
      by: ['type'],
      where,
      _count: true,
      _sum: {
        size: true,
      },
    });

    return {
      success: true,
      message: 'Media stats retrieved successfully',
      data: stats.map(stat => ({
        type: stat.type,
        count: stat._count,
        totalSize: stat._sum.size || 0,
      })),
    };
  }
}
```

#### 4.2.2 SearchController æ“´å±•

```typescript
// backend/src/search/search.controller.ts

import { Controller, Get, Query, UseGuards, Request } from '@nestjs/common';
import { SearchService } from './search.service';
import { MediaType } from '@prisma/client';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';

@Controller('search')
export class SearchController {
  constructor(private readonly searchService: SearchService) {}

  // æœå°‹æ–‡ç« ï¼ˆæ”¯æŒåª’é«”ç¯©é¸ï¼‰
  @Get('posts')
  async searchPosts(
    @Query('q') query: string,
    @Query('mediaType') mediaType?: MediaType,
    @Query('hasMedia') hasMedia?: string,
    @Query('author') authorId?: string,
    @Query('sort') sort?: 'latest' | 'popular' | 'relevant',
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    return this.searchService.searchPosts({
      query,
      mediaType,
      hasMedia: hasMedia === 'true',
      authorId,
      sort: sort || 'relevant',
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }

  // æœå°‹åª’é«”
  @Get('media')
  async searchMedia(
    @Query('q') query: string,
    @Query('type') type?: MediaType,
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    return this.searchService.searchMedia({
      query,
      type,
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }

  // ç²å–åª’é«”çµ±è¨ˆ
  @UseGuards(JwtAuthGuard)
  @Get('media/stats')
  async getMediaStats(@Request() req) {
    return this.searchService.getMediaStats(req.user.id);
  }
}
```

---

### 4.3 å‰ç«¯å¯¦ç¾ç¤ºä¾‹

#### 4.3.1 æ“´å±•æœå°‹æœå‹™

```typescript
// frontend/src/services/search.service.ts

export enum MediaType {
  IMAGE = 'IMAGE',
  VIDEO = 'VIDEO',
  DOCUMENT = 'DOCUMENT',
  AUDIO = 'AUDIO',
  OTHER = 'OTHER',
}

export const searchService = {
  /**
   * æœå°‹æ–‡ç« ï¼ˆæ”¯æŒåª’é«”ç¯©é¸ï¼‰
   */
  async searchPosts(params: {
    query: string;
    mediaType?: MediaType;
    hasMedia?: boolean;
    author?: string;
    sort?: 'latest' | 'popular' | 'relevant';
    page?: number;
    limit?: number;
  }) {
    const response = await apiClient.get('/search/posts', { params });
    return response.data;
  },

  /**
   * æœå°‹åª’é«”
   */
  async searchMedia(params: {
    query: string;
    type?: MediaType;
    page?: number;
    limit?: number;
  }) {
    const response = await apiClient.get('/search/media', { params });
    return response.data;
  },

  /**
   * ç²å–åª’é«”çµ±è¨ˆ
   */
  async getMediaStats() {
    const response = await apiClient.get('/search/media/stats');
    return response.data;
  },
};
```

#### 4.3.2 æœå°‹é é¢ UI

```typescript
// frontend/src/screens/SearchScreen.tsx

import React, { useState } from 'react';
import { View, ScrollView } from 'react-native';
import { Searchbar, Chip, SegmentedButtons } from 'react-native-paper';
import { MediaType } from '../services/search.service';

export default function SearchScreen() {
  const [query, setQuery] = useState('');
  const [searchType, setSearchType] = useState<'posts' | 'media'>('posts');
  const [mediaType, setMediaType] = useState<MediaType | null>(null);
  const [results, setResults] = useState([]);

  const mediaTypeOptions = [
    { value: null, label: 'å…¨éƒ¨', icon: 'all-inclusive' },
    { value: MediaType.IMAGE, label: 'åœ–ç‰‡', icon: 'image' },
    { value: MediaType.VIDEO, label: 'è¦–é »', icon: 'video' },
    { value: MediaType.DOCUMENT, label: 'æ–‡æª”', icon: 'file-document' },
  ];

  const handleSearch = async () => {
    if (!query.trim()) return;
    
    try {
      if (searchType === 'posts') {
        const data = await searchService.searchPosts({
          query,
          mediaType: mediaType || undefined,
          hasMedia: mediaType ? true : undefined,
        });
        setResults(data.posts);
      } else {
        const data = await searchService.searchMedia({
          query,
          type: mediaType || undefined,
        });
        setResults(data.media);
      }
    } catch (error) {
      console.error('Search error:', error);
    }
  };

  return (
    <View style={{ flex: 1, padding: 16 }}>
      {/* æœå°‹æ¡† */}
      <Searchbar
        placeholder="æœå°‹æ–‡ç« ã€åœ–ç‰‡ã€è¦–é »..."
        value={query}
        onChangeText={setQuery}
        onSubmitEditing={handleSearch}
      />

      {/* æœå°‹é¡å‹é¸æ“‡ */}
      <SegmentedButtons
        value={searchType}
        onValueChange={setSearchType}
        buttons={[
          { value: 'posts', label: 'æ–‡ç« ' },
          { value: 'media', label: 'åª’é«”' },
        ]}
        style={{ marginVertical: 12 }}
      />

      {/* åª’é«”é¡å‹ç¯©é¸ */}
      <ScrollView horizontal showsHorizontalScrollIndicator={false}>
        <View style={{ flexDirection: 'row', gap: 8 }}>
          {mediaTypeOptions.map((option) => (
            <Chip
              key={option.label}
              selected={mediaType === option.value}
              onPress={() => setMediaType(option.value)}
              icon={option.icon}
            >
              {option.label}
            </Chip>
          ))}
        </View>
      </ScrollView>

      {/* æœå°‹çµæœ */}
      <SearchResults results={results} type={searchType} />
    </View>
  );
}
```

---

## 5. æ–‡ä»¶ä¸Šå‚³åŠŸèƒ½å¯¦ç¾

### 5.1 å¾Œç«¯æ–‡ä»¶ä¸Šå‚³

#### 5.1.1 å®‰è£ä¾è³´

```bash
npm install --save @nestjs/platform-express multer
npm install --save-dev @types/multer
```

#### 5.1.2 MediaController

```typescript
// backend/src/media/media.controller.ts

import {
  Controller,
  Post,
  UploadedFile,
  UseInterceptors,
  UseGuards,
  Request,
  Body,
  BadRequestException,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';
import { MediaService } from './media.service';
import { diskStorage } from 'multer';
import { extname } from 'path';

@Controller('media')
export class MediaController {
  constructor(private readonly mediaService: MediaService) {}

  @UseGuards(JwtAuthGuard)
  @Post('upload')
  @UseInterceptors(
    FileInterceptor('file', {
      storage: diskStorage({
        destination: './uploads',
        filename: (req, file, cb) => {
          const randomName = Array(32)
            .fill(null)
            .map(() => Math.round(Math.random() * 16).toString(16))
            .join('');
          cb(null, `${randomName}${extname(file.originalname)}`);
        },
      }),
      limits: {
        fileSize: 50 * 1024 * 1024, // 50MB
      },
      fileFilter: (req, file, cb) => {
        // å…è¨±çš„æ–‡ä»¶é¡å‹
        const allowedMimes = [
          'image/jpeg',
          'image/png',
          'image/gif',
          'image/webp',
          'video/mp4',
          'video/webm',
          'application/pdf',
          'application/msword',
          'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        ];
        
        if (allowedMimes.includes(file.mimetype)) {
          cb(null, true);
        } else {
          cb(new BadRequestException('File type not allowed'), false);
        }
      },
    }),
  )
  async uploadFile(
    @UploadedFile() file: Express.Multer.File,
    @Body('postId') postId: string,
    @Body('description') description?: string,
    @Body('alt') alt?: string,
    @Request() req?,
  ) {
    if (!file) {
      throw new BadRequestException('No file uploaded');
    }

    return this.mediaService.createMedia({
      file,
      postId,
      uploaderId: req.user.id,
      description,
      alt,
    });
  }
}
```

#### 5.1.3 MediaService

```typescript
// backend/src/media/media.service.ts

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { MediaType } from '@prisma/client';

@Injectable()
export class MediaService {
  constructor(private prisma: PrismaService) {}

  async createMedia(params: {
    file: Express.Multer.File;
    postId: string;
    uploaderId: string;
    description?: string;
    alt?: string;
  }) {
    const { file, postId, uploaderId, description, alt } = params;

    // åˆ¤æ–·åª’é«”é¡å‹
    const type = this.getMediaType(file.mimetype);

    // ç²å–åœ–ç‰‡/è¦–é »å°ºå¯¸ï¼ˆå¯é¸ï¼Œéœ€è¦é¡å¤–çš„åº«ï¼‰
    // const dimensions = await this.getMediaDimensions(file.path, type);

    const media = await this.prisma.media.create({
      data: {
        type,
        url: `/uploads/${file.filename}`,
        filename: file.originalname,
        mimeType: file.mimetype,
        size: file.size,
        description,
        alt,
        postId,
        uploaderId,
      },
    });

    return {
      success: true,
      message: 'Media uploaded successfully',
      data: media,
    };
  }

  private getMediaType(mimeType: string): MediaType {
    if (mimeType.startsWith('image/')) return MediaType.IMAGE;
    if (mimeType.startsWith('video/')) return MediaType.VIDEO;
    if (mimeType.includes('pdf') || mimeType.includes('document')) {
      return MediaType.DOCUMENT;
    }
    return MediaType.OTHER;
  }
}
```

---

## 6. å¯¦æ–½è¨ˆåŠƒ

### 6.1 éšæ®µåŠƒåˆ†

#### éšæ®µ 0ï¼šæ•¸æ“šæ¨¡å‹é·ç§»ï¼ˆå¿…é ˆå…ˆå®Œæˆï¼‰
**æ™‚é–“ï¼š1-2 å¤©**

1. å‰µå»º Media æ¨¡å‹çš„ Prisma schema
2. åŸ·è¡Œæ•¸æ“šåº«é·ç§»
3. æ›´æ–°ç¾æœ‰æ–‡ç« çš„åœ–ç‰‡æ•¸æ“šï¼ˆé·ç§»è…³æœ¬ï¼‰

```bash
# å‰µå»ºé·ç§»
npx prisma migrate dev --name add_media_model

# åŸ·è¡Œæ•¸æ“šé·ç§»è…³æœ¬ï¼ˆå°‡ç¾æœ‰çš„ Post.image é·ç§»åˆ° Media è¡¨ï¼‰
npx ts-node prisma/migrate-images.ts
```

---

#### éšæ®µ 1ï¼šåŸºç¤åª’é«”ç®¡ç†ï¼ˆ2-3 å¤©ï¼‰

1. å¯¦ç¾æ–‡ä»¶ä¸Šå‚³ API
   - MediaController + MediaService
   - æ–‡ä»¶é©—è­‰å’Œå­˜å„²
   - æ”¯æŒåœ–ç‰‡ã€è¦–é »ã€æ–‡æª”

2. æ›´æ–°æ–‡ç« å‰µå»º/ç·¨è¼¯ API
   - æ”¯æŒæ·»åŠ å¤šå€‹åª’é«”
   - åª’é«”èˆ‡æ–‡ç« é—œè¯

3. å‰ç«¯åª’é«”ä¸Šå‚³çµ„ä»¶
   - åœ–ç‰‡ä¸Šå‚³
   - è¦–é »ä¸Šå‚³
   - æ–‡ä»¶ä¸Šå‚³
   - ä¸Šå‚³é€²åº¦é¡¯ç¤º

---

#### éšæ®µ 2ï¼šåª’é«”æœå°‹åŠŸèƒ½ï¼ˆ2-3 å¤©ï¼‰

1. å¯¦ç¾åª’é«”æœå°‹ API
   - æŒ‰æ–‡ä»¶åæœå°‹
   - æŒ‰åª’é«”é¡å‹ç¯©é¸
   - æŒ‰æè¿°æœå°‹

2. æ“´å±•æ–‡ç« æœå°‹ API
   - æ”¯æŒæŒ‰åª’é«”é¡å‹ç¯©é¸
   - æœå°‹åŒ…å«ç‰¹å®šåª’é«”çš„æ–‡ç« 

3. å‰ç«¯æœå°‹ç•Œé¢
   - åª’é«”é¡å‹ç¯©é¸å™¨
   - åª’é«”æœå°‹çµæœå±•ç¤º
   - åª’é«”é è¦½

---

#### éšæ®µ 3ï¼šé€²éšåŠŸèƒ½ï¼ˆå¯é¸ï¼Œ3-5 å¤©ï¼‰

1. åª’é«”ç®¡ç†
   - ç”¨æˆ¶åª’é«”åº«
   - æ‰¹é‡ä¸Šå‚³
   - åª’é«”ç·¨è¼¯å’Œåˆªé™¤

2. åœ–ç‰‡è™•ç†
   - è‡ªå‹•ç”Ÿæˆç¸®ç•¥åœ–
   - åœ–ç‰‡å£“ç¸®
   - å°ºå¯¸èª¿æ•´

3. è¦–é »è™•ç†
   - è¦–é »ç¸®ç•¥åœ–ç”Ÿæˆ
   - è¦–é »è½‰ç¢¼ï¼ˆå¯é¸ï¼‰
   - è¦–é »æ’­æ”¾å™¨

---

### 6.2 ç¸½æ™‚é–“ä¼°ç®—

| éšæ®µ | æ™‚é–“ | å„ªå…ˆç´š |
|-----|------|--------|
| éšæ®µ 0ï¼šæ•¸æ“šæ¨¡å‹é·ç§» | 1-2 å¤© | â­â­â­â­â­ å¿…é ˆ |
| éšæ®µ 1ï¼šåŸºç¤åª’é«”ç®¡ç† | 2-3 å¤© | â­â­â­â­â­ å¿…é ˆ |
| éšæ®µ 2ï¼šåª’é«”æœå°‹åŠŸèƒ½ | 2-3 å¤© | â­â­â­â­ é‡è¦ |
| éšæ®µ 3ï¼šé€²éšåŠŸèƒ½ | 3-5 å¤© | â­â­â­ å¯é¸ |

**æœ€å°å¯è¡Œç”¢å“ï¼ˆMVPï¼‰ï¼š** éšæ®µ 0 + éšæ®µ 1 = 3-5 å¤©  
**å®Œæ•´æœå°‹åŠŸèƒ½ï¼š** éšæ®µ 0 + 1 + 2 = 5-8 å¤©  
**å®Œæ•´åŠŸèƒ½ï¼š** æ‰€æœ‰éšæ®µ = 8-13 å¤©

---

## 7. æŠ€è¡“æŒ‘æˆ°èˆ‡è§£æ±ºæ–¹æ¡ˆ

### 7.1 æ–‡ä»¶å­˜å„²

#### æŒ‘æˆ°
- æœ¬åœ°å­˜å„²å®¹é‡é™åˆ¶
- æ–‡ä»¶è¨ªå•é€Ÿåº¦
- å‚™ä»½å’Œæ¢å¾©

#### è§£æ±ºæ–¹æ¡ˆ

**æ–¹æ¡ˆ Aï¼šæœ¬åœ°å­˜å„²ï¼ˆé–‹ç™¼/å°è¦æ¨¡ï¼‰**
```typescript
// ç°¡å–®ä½†æœ‰é™åˆ¶
storage: diskStorage({
  destination: './uploads',
  filename: (req, file, cb) => {
    // ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
  },
})
```

**æ–¹æ¡ˆ Bï¼šé›²ç«¯å­˜å„²ï¼ˆæ¨è–¦ç”¨æ–¼ç”Ÿç”¢ï¼‰**
- AWS S3
- Google Cloud Storage
- Cloudflare R2ï¼ˆæ€§åƒ¹æ¯”é«˜ï¼‰
- Backblaze B2ï¼ˆä¾¿å®œï¼‰

```typescript
// ä½¿ç”¨ AWS S3 ç¤ºä¾‹
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

const s3Client = new S3Client({ region: 'us-east-1' });

async uploadToS3(file: Express.Multer.File) {
  const command = new PutObjectCommand({
    Bucket: 'your-bucket',
    Key: `uploads/${Date.now()}-${file.originalname}`,
    Body: file.buffer,
    ContentType: file.mimetype,
  });
  
  await s3Client.send(command);
}
```

---

### 7.2 åœ–ç‰‡/è¦–é »è™•ç†

#### æŒ‘æˆ°
- åœ–ç‰‡éœ€è¦å£“ç¸®å’Œç”Ÿæˆç¸®ç•¥åœ–
- è¦–é »éœ€è¦ç”Ÿæˆé è¦½åœ–
- è™•ç†è€—æ™‚å¯èƒ½å½±éŸ¿ç”¨æˆ¶é«”é©—

#### è§£æ±ºæ–¹æ¡ˆ

**æ–¹æ¡ˆ Aï¼šä½¿ç”¨ Sharpï¼ˆåœ–ç‰‡è™•ç†ï¼‰**
```typescript
import sharp from 'sharp';

async processImage(inputPath: string) {
  // ç”Ÿæˆç¸®ç•¥åœ–
  await sharp(inputPath)
    .resize(300, 300, { fit: 'cover' })
    .toFile(`${inputPath}-thumb.jpg`);
    
  // å£“ç¸®åŸåœ–
  await sharp(inputPath)
    .jpeg({ quality: 80 })
    .toFile(`${inputPath}-optimized.jpg`);
}
```

**æ–¹æ¡ˆ Bï¼šä½¿ç”¨ FFmpegï¼ˆè¦–é »è™•ç†ï¼‰**
```typescript
import ffmpeg from 'fluent-ffmpeg';

async generateVideoThumbnail(videoPath: string) {
  return new Promise((resolve, reject) => {
    ffmpeg(videoPath)
      .screenshots({
        timestamps: ['00:00:01'],
        filename: 'thumbnail.jpg',
        folder: './thumbnails',
      })
      .on('end', resolve)
      .on('error', reject);
  });
}
```

**æ–¹æ¡ˆ Cï¼šå¾Œå°ä»»å‹™éšŠåˆ—ï¼ˆæ¨è–¦ï¼‰**
```typescript
// ä½¿ç”¨ Bull Queue è™•ç†è€—æ™‚ä»»å‹™
import { Queue } from 'bull';

const mediaProcessingQueue = new Queue('media-processing');

// æ·»åŠ ä»»å‹™
await mediaProcessingQueue.add('process-image', {
  mediaId: media.id,
  path: media.url,
});

// è™•ç†ä»»å‹™ï¼ˆworkerï¼‰
mediaProcessingQueue.process('process-image', async (job) => {
  const { mediaId, path } = job.data;
  // åŸ·è¡Œå£“ç¸®ã€ç”Ÿæˆç¸®ç•¥åœ–ç­‰
});
```

---

### 7.3 æœå°‹æ€§èƒ½

#### æŒ‘æˆ°
- å¤šåª’é«”æœå°‹å¯èƒ½æ¶‰åŠå¤šè¡¨ JOIN
- æ–‡ä»¶åå’Œæè¿°çš„å…¨æ–‡æœå°‹

#### è§£æ±ºæ–¹æ¡ˆ

1. **æ•¸æ“šåº«ç´¢å¼•**
```sql
-- æ–‡ä»¶åç´¢å¼•
CREATE INDEX idx_media_filename ON media(filename);

-- æè¿°å…¨æ–‡ç´¢å¼•
CREATE INDEX idx_media_description_fts ON media USING gin(to_tsvector('english', description));

-- å¾©åˆç´¢å¼•
CREATE INDEX idx_media_type_created ON media(type, created_at DESC);
```

2. **æŸ¥è©¢å„ªåŒ–**
```typescript
// ä½¿ç”¨ Prisma çš„é«˜æ•ˆæŸ¥è©¢
const posts = await prisma.post.findMany({
  where: {
    media: {
      some: { type: MediaType.VIDEO }
    }
  },
  include: {
    media: {
      where: { type: MediaType.VIDEO }  // åªè¼‰å…¥è¦–é »
    }
  }
});
```

3. **ç·©å­˜**
```typescript
// ä½¿ç”¨ Redis ç·©å­˜ç†±é–€æœå°‹çµæœ
import { Redis } from 'ioredis';
const redis = new Redis();

const cacheKey = `search:${query}:${mediaType}`;
const cached = await redis.get(cacheKey);

if (cached) {
  return JSON.parse(cached);
}

// åŸ·è¡Œæœå°‹...
await redis.set(cacheKey, JSON.stringify(results), 'EX', 300); // 5åˆ†é˜
```

---

## 8. å®‰å…¨æ€§è€ƒæ…®

### 8.1 æ–‡ä»¶é©—è­‰

```typescript
// åš´æ ¼çš„æ–‡ä»¶é¡å‹æª¢æŸ¥
const ALLOWED_MIME_TYPES = {
  IMAGE: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
  VIDEO: ['video/mp4', 'video/webm', 'video/quicktime'],
  DOCUMENT: ['application/pdf', 'application/msword', /* ... */],
};

// æ–‡ä»¶å¤§å°é™åˆ¶
const MAX_FILE_SIZE = {
  IMAGE: 10 * 1024 * 1024,      // 10MB
  VIDEO: 100 * 1024 * 1024,     // 100MB
  DOCUMENT: 20 * 1024 * 1024,   // 20MB
};

// æ–‡ä»¶å…§å®¹é©—è­‰ï¼ˆé˜²æ­¢å½è£ï¼‰
import fileType from 'file-type';

const type = await fileType.fromBuffer(file.buffer);
if (type.mime !== file.mimetype) {
  throw new Error('File type mismatch');
}
```

### 8.2 è¨ªå•æ§åˆ¶

```typescript
// åªæœ‰æ–‡ç« ä½œè€…å¯ä»¥åˆªé™¤åª’é«”
async deleteMedia(mediaId: string, userId: string) {
  const media = await this.prisma.media.findUnique({
    where: { id: mediaId },
    include: { post: true },
  });
  
  if (media.post.authorId !== userId) {
    throw new ForbiddenException('Not authorized');
  }
  
  // åˆªé™¤æ–‡ä»¶å’Œæ•¸æ“šåº«è¨˜éŒ„
  await this.deleteFile(media.url);
  await this.prisma.media.delete({ where: { id: mediaId } });
}
```

### 8.3 é˜²æ­¢æ¿«ç”¨

```typescript
// é™åˆ¶ä¸Šå‚³é »ç‡
import { Throttle } from '@nestjs/throttler';

@Throttle(10, 60)  // æ¯åˆ†é˜æœ€å¤š 10 æ¬¡
@Post('upload')
async uploadFile() {
  // ...
}

// é™åˆ¶ç”¨æˆ¶ç¸½å­˜å„²ç©ºé–“
async checkUserQuota(userId: string) {
  const totalSize = await this.prisma.media.aggregate({
    where: { uploaderId: userId },
    _sum: { size: true },
  });
  
  const MAX_QUOTA = 1024 * 1024 * 1024;  // 1GB
  if (totalSize._sum.size > MAX_QUOTA) {
    throw new BadRequestException('Storage quota exceeded');
  }
}
```

---

## 9. æˆæœ¬åˆ†æ

### 9.1 é–‹ç™¼æˆæœ¬

| é …ç›® | æ™‚é–“ | è¤‡é›œåº¦ |
|-----|------|--------|
| æ•¸æ“šæ¨¡å‹è¨­è¨ˆå’Œé·ç§» | 1-2 å¤© | ğŸŸ¡ ä¸­ |
| æ–‡ä»¶ä¸Šå‚³åŠŸèƒ½ | 2-3 å¤© | ğŸŸ¡ ä¸­ |
| åª’é«”ç®¡ç† API | 2-3 å¤© | ğŸŸ¡ ä¸­ |
| æœå°‹åŠŸèƒ½æ“´å±• | 2-3 å¤© | ğŸŸ¡ ä¸­ |
| å‰ç«¯ UI é–‹ç™¼ | 3-4 å¤© | ğŸŸ¡ ä¸­ |
| åœ–ç‰‡/è¦–é »è™•ç† | 2-3 å¤© | ğŸ”´ é«˜ |
| æ¸¬è©¦å’Œå„ªåŒ– | 2-3 å¤© | ğŸŸ¡ ä¸­ |
| **ç¸½è¨ˆ** | **14-21 å¤©** | - |

### 9.2 é‹ç‡Ÿæˆæœ¬

**å­˜å„²æˆæœ¬ï¼ˆæœˆï¼‰ï¼š**
- æœ¬åœ°å­˜å„²ï¼š$0ï¼ˆä½†æœ‰é™åˆ¶ï¼‰
- AWS S3ï¼š$0.023/GBï¼ˆæ¨™æº–å­˜å„²ï¼‰
- Cloudflare R2ï¼š$0.015/GBï¼ˆç„¡å‡ºç«™æµé‡è²»ï¼‰
- Backblaze B2ï¼š$0.005/GBï¼ˆæœ€ä¾¿å®œï¼‰

**ç¤ºä¾‹ï¼ˆ1000 ç”¨æˆ¶ï¼Œæ¯äººå¹³å‡ 100MBï¼‰ï¼š**
- ç¸½å­˜å„²ï¼š100GB
- AWS S3ï¼š~$2.30/æœˆ
- Cloudflare R2ï¼š~$1.50/æœˆ
- Backblaze B2ï¼š~$0.50/æœˆ

**CDN æˆæœ¬ï¼š**
- Cloudflareï¼šå…è²»ï¼ˆåŸºç¤ï¼‰
- AWS CloudFrontï¼š$0.085/GBï¼ˆæµé‡ï¼‰

---

## 10. ç¸½çµèˆ‡å»ºè­°

### 10.1 æ¨è–¦å¯¦æ–½è·¯å¾‘

```
ç¬¬ä¸€éšæ®µï¼ˆå¿…é ˆï¼‰ï¼š
1. è¨­è¨ˆå’Œå¯¦ç¾ Media æ•¸æ“šæ¨¡å‹
2. åŸºç¤æ–‡ä»¶ä¸Šå‚³åŠŸèƒ½ï¼ˆåœ–ç‰‡å„ªå…ˆï¼‰
3. æ›´æ–°æ–‡ç« å‰µå»º/ç·¨è¼¯æµç¨‹
   â†“
ç¬¬äºŒéšæ®µï¼ˆé‡è¦ï¼‰ï¼š
4. æ“´å±•æ”¯æŒè¦–é »å’Œæ–‡æª”
5. å¯¦ç¾åª’é«”æœå°‹åŠŸèƒ½
6. æ·»åŠ åª’é«”é¡å‹ç¯©é¸
   â†“
ç¬¬ä¸‰éšæ®µï¼ˆå„ªåŒ–ï¼‰ï¼š
7. åœ–ç‰‡å£“ç¸®å’Œç¸®ç•¥åœ–
8. è¦–é »è™•ç†å’Œé è¦½
9. åª’é«”ç®¡ç†ç•Œé¢
```

### 10.2 é—œéµå»ºè­°

1. **å…ˆå®ŒæˆåŸºç¤æ–‡å­—æœå°‹**
   - å¦‚æœé‚„æ²’å¯¦ç¾åŸºç¤æœå°‹ï¼Œå»ºè­°å…ˆå®Œæˆï¼ˆåƒè€ƒ `æœå°‹åŠŸèƒ½åˆ†æè©•ä¼°.md`ï¼‰
   - åª’é«”æœå°‹å¯ä»¥ä½œç‚ºæ“´å±•åŠŸèƒ½

2. **å„ªå…ˆæ”¯æŒåœ–ç‰‡**
   - åœ–ç‰‡æ˜¯æœ€å¸¸ç”¨çš„åª’é«”é¡å‹
   - å¯¦ç¾ç›¸å°ç°¡å–®
   - ç”¨æˆ¶éœ€æ±‚æœ€é«˜

3. **é¸æ“‡åˆé©çš„å­˜å„²æ–¹æ¡ˆ**
   - é–‹ç™¼éšæ®µï¼šæœ¬åœ°å­˜å„²
   - ç”Ÿç”¢ç’°å¢ƒï¼šé›²ç«¯å­˜å„²ï¼ˆæ¨è–¦ Cloudflare R2 æˆ– Backblaze B2ï¼‰

4. **æ€§èƒ½å„ªåŒ–**
   - æ·»åŠ é©ç•¶çš„æ•¸æ“šåº«ç´¢å¼•
   - ä½¿ç”¨ CDN åŠ é€Ÿåª’é«”è¨ªå•
   - å¾Œå°è™•ç†è€—æ™‚ä»»å‹™

5. **å®‰å…¨ç¬¬ä¸€**
   - åš´æ ¼çš„æ–‡ä»¶é¡å‹é©—è­‰
   - æ–‡ä»¶å¤§å°é™åˆ¶
   - è¨ªå•æ¬Šé™æ§åˆ¶
   - é˜²æ­¢æ¿«ç”¨ï¼ˆé™æµã€é…é¡ï¼‰

### 10.3 é¢¨éšªæç¤º

âš ï¸ **é«˜é¢¨éšªé …ç›®ï¼š**
- å­˜å„²æˆæœ¬å¯èƒ½å¿«é€Ÿå¢é•·
- è¦–é »è™•ç†è¤‡é›œä¸”è€—è³‡æº
- éœ€è¦å®Œå–„çš„å®‰å…¨æ©Ÿåˆ¶

ğŸŸ¡ **ä¸­é¢¨éšªé …ç›®ï¼š**
- æ•¸æ“šåº«é·ç§»å¯èƒ½å½±éŸ¿ç¾æœ‰æ•¸æ“š
- æœå°‹æ€§èƒ½éœ€è¦å„ªåŒ–
- å‰ç«¯ UI é–‹ç™¼å·¥ä½œé‡è¼ƒå¤§

### 10.4 æ˜¯å¦ç¾åœ¨å¯¦æ–½ï¼Ÿ

**å»ºè­°æš«ç·©å¯¦æ–½ï¼Œå„ªå…ˆå®Œæˆï¼š**
1. âœ… æ ¸å¿ƒåŠŸèƒ½ç©©å®šï¼ˆç™¼æ–‡ã€è©•è«–ã€é»è®šï¼‰
2. âœ… åŸºç¤æœå°‹åŠŸèƒ½ï¼ˆæ–‡å­—æœå°‹ï¼‰
3. âœ… ç”¨æˆ¶é‡é”åˆ°ä¸€å®šè¦æ¨¡
4. âœ… æ˜ç¢ºçš„ç”¨æˆ¶éœ€æ±‚

**é©åˆå¯¦æ–½çš„æ™‚æ©Ÿï¼š**
- åŸºç¤åŠŸèƒ½å·²ç¶“ç©©å®šé‹è¡Œ
- ç”¨æˆ¶æœ‰æ˜ç¢ºçš„å¤šåª’é«”åˆ†äº«éœ€æ±‚
- åœ˜éšŠæœ‰å……è¶³çš„é–‹ç™¼æ™‚é–“ï¼ˆ2-3 é€±ï¼‰
- é ç®—å¯ä»¥æ”¯æŒå­˜å„²å’Œè™•ç†æˆæœ¬

---

**æ–‡æª”ç‰ˆæœ¬ï¼š** v1.0  
**å‰µå»ºæ—¥æœŸï¼š** 2025-10-29  
**ä½œè€…ï¼š** HAPPY SHARE é–‹ç™¼åœ˜éšŠ  
**ç‹€æ…‹ï¼š** ğŸ“‹ è¦åŠƒä¸­ - å»ºè­°æš«ç·©å¯¦æ–½
