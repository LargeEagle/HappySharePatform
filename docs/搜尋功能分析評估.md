# 搜尋功能分析評估文檔

## 1. 功能概述

### 1.1 功能目標
為 HAPPY SHARE 社交平台添加全面的搜尋功能，讓用戶能夠快速找到感興趣的內容、用戶和話題。

### 1.2 核心價值
- **內容發現**：幫助用戶發現新的有趣內容
- **用戶連接**：促進用戶之間的互動和關注
- **提升參與度**：增加用戶在平台的活躍時間
- **改善體驗**：提供更便捷的導航和內容訪問

## 2. 功能範圍分析

### 2.1 搜尋對象

#### 2.1.1 文章搜尋 (Posts Search) - 優先級：⭐⭐⭐⭐⭐
**搜尋欄位：**
- `title` - 文章標題（主要）
- `content` - 文章內容（次要）
- `authorId` - 作者（關聯搜尋）

**搜尋條件：**
- 關鍵字匹配（標題、內容）
- 作者篩選
- 時間範圍篩選
- 發布狀態篩選（已發布 vs 草稿）
- 熱門度排序（likesCount, commentsCount）
- 時間排序（最新、最早）

**實現複雜度：** 🟢 低-中
**用戶需求度：** 🔴 高
**技術可行性：** ✅ 高

---

#### 2.1.2 用戶搜尋 (Users Search) - 優先級：⭐⭐⭐⭐
**搜尋欄位：**
- `username` - 用戶名（主要）
- `name` - 顯示名稱（主要）
- `bio` - 個人簡介（次要）
- `location` - 地點（可選）

**搜尋條件：**
- 關鍵字匹配（用戶名、名稱、簡介）
- 地點篩選
- 粉絲數排序
- 活躍度排序（發文數、互動數）

**實現複雜度：** 🟢 低
**用戶需求度：** 🟡 中-高
**技術可行性：** ✅ 高

---

#### 2.1.3 評論搜尋 (Comments Search) - 優先級：⭐⭐⭐
**搜尋欄位：**
- `content` - 評論內容

**搜尋條件：**
- 關鍵字匹配
- 作者篩選
- 時間範圍
- 按文章搜尋評論

**實現複雜度：** 🟢 低
**用戶需求度：** 🟡 中
**技術可行性：** ✅ 高

---

#### 2.1.4 標籤搜尋 (Tags/Hashtags Search) - 優先級：⭐⭐
**當前狀態：** ❌ 數據庫模型中未實現標籤功能
**需求：** 需要先實現標籤系統

**所需新增模型：**
```prisma
model Tag {
  id        String   @id @default(uuid())
  name      String   @unique
  count     Int      @default(0)  // 使用次數
  createdAt DateTime @default(now())
  
  posts     PostTag[]
  
  @@map("tags")
}

model PostTag {
  id        String   @id @default(uuid())
  postId    String
  tagId     String
  createdAt DateTime @default(now())
  
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  @@unique([postId, tagId])
  @@index([postId])
  @@index([tagId])
  @@map("post_tags")
}
```

**實現複雜度：** 🟡 中（需要先實現標籤系統）
**用戶需求度：** 🟡 中
**技術可行性：** ✅ 高（但需要額外開發）

---

### 2.2 搜尋功能類型

#### 2.2.1 基礎文字搜尋（第一階段）- 推薦優先實現
**技術方案：**
- 使用 PostgreSQL 的 `ILIKE` 進行模糊匹配
- 支持大小寫不敏感搜尋
- 簡單、快速、易實現

**優點：**
- ✅ 實現簡單，開發成本低
- ✅ 適合小到中型數據量（< 100萬筆記錄）
- ✅ 維護成本低，無需額外服務

**缺點：**
- ⚠️ 性能隨數據量增長而下降
- ⚠️ 不支持複雜的相關性排序
- ⚠️ 中文分詞效果一般

**適用場景：**
- MVP 階段
- 數據量較小時（< 10萬筆文章）
- 需要快速上線基礎功能

**示例實現：**
```typescript
// 基礎 ILIKE 搜尋
const posts = await prisma.post.findMany({
  where: {
    OR: [
      { title: { contains: keyword, mode: 'insensitive' } },
      { content: { contains: keyword, mode: 'insensitive' } },
    ],
    isPublished: true,
  },
  orderBy: { createdAt: 'desc' },
  take: limit,
  skip: (page - 1) * limit,
});
```

---

#### 2.2.2 全文搜尋（第二階段）
**技術方案：**
- PostgreSQL Full-Text Search (FTS)
- 使用 `tsvector` 和 `tsquery`
- 支持權重、排名和相關性評分

**優點：**
- ✅ 性能更好，支持更大數據量
- ✅ 支持相關性排序
- ✅ 內建於 PostgreSQL，無需額外服務
- ✅ 支持多語言（包括中文）

**缺點：**
- ⚠️ 實現較複雜，需要配置
- ⚠️ 需要創建額外的索引
- ⚠️ 中文分詞需要特別配置

**適用場景：**
- 數據量較大時（> 10萬筆）
- 需要更好的搜尋體驗
- 需要相關性排序

**示例實現：**
```sql
-- 添加全文搜尋欄位
ALTER TABLE posts ADD COLUMN search_vector tsvector;

-- 創建索引
CREATE INDEX posts_search_idx ON posts USING gin(search_vector);

-- 更新搜尋向量（trigger）
CREATE TRIGGER posts_search_vector_update
BEFORE INSERT OR UPDATE ON posts
FOR EACH ROW EXECUTE FUNCTION
tsvector_update_trigger(search_vector, 'pg_catalog.english', title, content);
```

---

#### 2.2.3 進階搜尋引擎（第三階段）- 可選
**技術方案：**
- Elasticsearch / Meilisearch / Typesense
- 專業搜尋引擎，功能強大

**優點：**
- ✅ 性能極佳，支持海量數據
- ✅ 豐富的搜尋功能（模糊搜尋、同義詞、拼音搜尋）
- ✅ 出色的中文分詞
- ✅ 實時搜尋建議
- ✅ 高級過濾和聚合

**缺點：**
- ❌ 架構複雜，維護成本高
- ❌ 需要額外服務器/資源
- ❌ 數據同步問題
- ❌ 學習曲線較陡

**適用場景：**
- 大型平台（> 100萬用戶，> 1000萬文章）
- 需要專業級搜尋體驗
- 有充足的技術資源

## 3. 技術實現方案

### 3.1 推薦方案（階段一：基礎搜尋）

#### 3.1.1 後端實現

**新增路由結構：**
```
GET /api/search?q=keyword&type=posts&page=1&limit=10
GET /api/search/posts?q=keyword&author=userId&sort=latest
GET /api/search/users?q=keyword&sort=followers
GET /api/search/comments?q=keyword&postId=xxx
```

**新增 SearchController：**
```typescript
// backend/src/search/search.controller.ts
import { Controller, Get, Query } from '@nestjs/common';
import { SearchService } from './search.service';

@Controller('search')
export class SearchController {
  constructor(private readonly searchService: SearchService) {}

  // 統一搜尋接口
  @Get()
  async search(
    @Query('q') query: string,
    @Query('type') type?: 'posts' | 'users' | 'comments' | 'all',
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    return this.searchService.search({
      query,
      type: type || 'all',
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }

  // 專門的文章搜尋
  @Get('posts')
  async searchPosts(
    @Query('q') query: string,
    @Query('author') authorId?: string,
    @Query('sort') sort?: 'latest' | 'popular' | 'relevant',
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    return this.searchService.searchPosts({
      query,
      authorId,
      sort: sort || 'relevant',
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }

  // 專門的用戶搜尋
  @Get('users')
  async searchUsers(
    @Query('q') query: string,
    @Query('sort') sort?: 'relevant' | 'followers' | 'posts',
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    return this.searchService.searchUsers({
      query,
      sort: sort || 'relevant',
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
    });
  }
}
```

**新增 SearchService：**
```typescript
// backend/src/search/search.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class SearchService {
  constructor(private prisma: PrismaService) {}

  async searchPosts(params: {
    query: string;
    authorId?: string;
    sort?: 'latest' | 'popular' | 'relevant';
    page: number;
    limit: number;
  }) {
    const { query, authorId, sort, page, limit } = params;
    const skip = (page - 1) * limit;

    const where = {
      isPublished: true,
      ...(authorId && { authorId }),
      OR: [
        { title: { contains: query, mode: 'insensitive' as const } },
        { content: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    // 排序邏輯
    let orderBy: any = { createdAt: 'desc' }; // 默認最新
    if (sort === 'popular') {
      orderBy = [
        { likesCount: 'desc' },
        { commentsCount: 'desc' },
        { createdAt: 'desc' },
      ];
    }

    const [posts, total] = await Promise.all([
      this.prisma.post.findMany({
        where,
        include: {
          author: {
            select: {
              id: true,
              username: true,
              name: true,
              avatar: true,
            },
          },
        },
        orderBy,
        skip,
        take: limit,
      }),
      this.prisma.post.count({ where }),
    ]);

    return {
      success: true,
      message: 'Posts retrieved successfully',
      data: {
        posts,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasMore: page * limit < total,
        },
      },
    };
  }

  async searchUsers(params: {
    query: string;
    sort?: 'relevant' | 'followers' | 'posts';
    page: number;
    limit: number;
  }) {
    const { query, sort, page, limit } = params;
    const skip = (page - 1) * limit;

    const where = {
      OR: [
        { username: { contains: query, mode: 'insensitive' as const } },
        { name: { contains: query, mode: 'insensitive' as const } },
        { bio: { contains: query, mode: 'insensitive' as const } },
      ],
    };

    let orderBy: any = { followersCount: 'desc' }; // 默認按粉絲數
    if (sort === 'posts') {
      orderBy = { postsCount: 'desc' };
    }

    const [users, total] = await Promise.all([
      this.prisma.user.findMany({
        where,
        select: {
          id: true,
          username: true,
          name: true,
          bio: true,
          avatar: true,
          location: true,
          followersCount: true,
          postsCount: true,
        },
        orderBy,
        skip,
        take: limit,
      }),
      this.prisma.user.count({ where }),
    ]);

    return {
      success: true,
      message: 'Users retrieved successfully',
      data: {
        users,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasMore: page * limit < total,
        },
      },
    };
  }

  async search(params: {
    query: string;
    type: 'posts' | 'users' | 'comments' | 'all';
    page: number;
    limit: number;
  }) {
    const { query, type, page, limit } = params;

    if (type === 'posts') {
      return this.searchPosts({ query, page, limit });
    }

    if (type === 'users') {
      return this.searchUsers({ query, page, limit });
    }

    if (type === 'all') {
      // 綜合搜尋：返回所有類型的結果
      const [posts, users] = await Promise.all([
        this.searchPosts({ query, page: 1, limit: 5 }),
        this.searchUsers({ query, page: 1, limit: 5 }),
      ]);

      return {
        success: true,
        message: 'Search completed successfully',
        data: {
          posts: posts.data.posts,
          users: users.data.users,
          query,
        },
      };
    }
  }
}
```

---

#### 3.1.2 前端實現

**新增搜尋服務：**
```typescript
// frontend/src/services/search.service.ts
import { apiClient } from './api.client';
import { Post } from '../types/post';
import { User } from '../types/auth';

interface SearchParams {
  query: string;
  type?: 'posts' | 'users' | 'all';
  page?: number;
  limit?: number;
}

interface SearchPostsParams extends SearchParams {
  author?: string;
  sort?: 'latest' | 'popular' | 'relevant';
}

interface SearchUsersParams extends SearchParams {
  sort?: 'relevant' | 'followers' | 'posts';
}

export const searchService = {
  // 通用搜尋
  async search(params: SearchParams) {
    const response = await apiClient.get('/search', { params });
    return response.data;
  },

  // 搜尋文章
  async searchPosts(params: SearchPostsParams) {
    const response = await apiClient.get('/search/posts', { params });
    return {
      posts: response.data.posts as Post[],
      pagination: response.data.pagination,
    };
  },

  // 搜尋用戶
  async searchUsers(params: SearchUsersParams) {
    const response = await apiClient.get('/search/users', { params });
    return {
      users: response.data.users as User[],
      pagination: response.data.pagination,
    };
  },
};
```

**新增搜尋頁面：**
```typescript
// frontend/src/screens/SearchScreen.tsx
import React, { useState } from 'react';
import { View, FlatList } from 'react-native';
import { Searchbar, SegmentedButtons, Card } from 'react-native-paper';
import { searchService } from '../services/search.service';
import PostCard from '../components/common/PostCard';

export default function SearchScreen() {
  const [query, setQuery] = useState('');
  const [type, setType] = useState<'posts' | 'users' | 'all'>('posts');
  const [results, setResults] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);

  const handleSearch = async () => {
    if (!query.trim()) return;
    
    setLoading(true);
    try {
      const data = await searchService.search({ query, type });
      setResults(type === 'posts' ? data.posts : data.users);
    } catch (error) {
      console.error('Search error:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={{ flex: 1, padding: 16 }}>
      <Searchbar
        placeholder="搜尋文章、用戶..."
        value={query}
        onChangeText={setQuery}
        onSubmitEditing={handleSearch}
      />
      
      <SegmentedButtons
        value={type}
        onValueChange={(value) => setType(value as any)}
        buttons={[
          { value: 'posts', label: '文章' },
          { value: 'users', label: '用戶' },
          { value: 'all', label: '全部' },
        ]}
        style={{ marginVertical: 16 }}
      />

      <FlatList
        data={results}
        renderItem={({ item }) => 
          type === 'posts' ? (
            <PostCard post={item} />
          ) : (
            <Card>
              {/* 用戶卡片 */}
            </Card>
          )
        }
        keyExtractor={(item) => item.id}
        refreshing={loading}
        onRefresh={handleSearch}
      />
    </View>
  );
}
```

---

### 3.2 數據庫優化

#### 3.2.1 添加索引（必須）
```sql
-- 為搜尋常用欄位添加索引
CREATE INDEX idx_posts_title ON posts(title);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_name ON users(name);

-- 復合索引（提升排序性能）
CREATE INDEX idx_posts_published_created ON posts(is_published, created_at DESC);
CREATE INDEX idx_posts_published_likes ON posts(is_published, likes_count DESC);
```

#### 3.2.2 Prisma Schema 更新
```prisma
model Post {
  // ... 現有欄位 ...
  
  @@index([title]) // 添加標題索引
  @@index([isPublished, createdAt])
  @@index([isPublished, likesCount])
}

model User {
  // ... 現有欄位 ...
  
  @@index([username]) // 添加用戶名索引
  @@index([name]) // 添加名稱索引
}
```

---

## 4. 實現優先級建議

### 階段一：MVP 基礎搜尋（推薦先實現）
**時間估計：2-3 天**

**包含功能：**
- ✅ 文章標題搜尋（ILIKE）
- ✅ 用戶名搜尋（ILIKE）
- ✅ 基礎分頁
- ✅ 簡單排序（最新、熱門）
- ✅ 搜尋結果列表頁面

**開發任務：**
1. 後端：SearchController + SearchService（2 個文件）
2. 前端：SearchScreen + searchService（2 個文件）
3. 數據庫：添加基礎索引（1 個 migration）
4. 測試：API 測試（1 個測試配置）

**優點：**
- 快速上線，滿足基本需求
- 實現簡單，風險低
- 可以快速收集用戶反饋

---

### 階段二：增強搜尋（可選）
**時間估計：3-5 天**

**包含功能：**
- ✅ 文章內容搜尋（全文搜尋）
- ✅ 用戶簡介搜尋
- ✅ 高級過濾（作者、時間範圍、分類）
- ✅ 相關性排序
- ✅ 搜尋歷史記錄
- ✅ 熱門搜尋建議

**開發任務：**
1. 後端：升級為 PostgreSQL Full-Text Search
2. 前端：添加高級搜尋界面
3. 數據庫：添加全文索引
4. 優化：性能調優

---

### 階段三：專業級搜尋（未來考慮）
**時間估計：1-2 週**

**包含功能：**
- ✅ 即時搜尋建議（autocomplete）
- ✅ 模糊搜尋（拼寫糾錯）
- ✅ 同義詞支持
- ✅ 拼音搜尋（中文）
- ✅ 標籤搜尋（需先實現標籤系統）
- ✅ 搜尋分析和統計

**技術選型：**
- Meilisearch（推薦，易用）
- Elasticsearch（功能強大但複雜）
- Typesense（輕量級，性能好）

---

## 5. 成本效益分析

### 5.1 開發成本

| 階段 | 開發時間 | 技術難度 | 維護成本 |
|------|---------|---------|---------|
| 階段一：基礎搜尋 | 2-3 天 | 🟢 低 | 🟢 低 |
| 階段二：增強搜尋 | 3-5 天 | 🟡 中 | 🟡 中 |
| 階段三：專業搜尋 | 1-2 週 | 🔴 高 | 🔴 高 |

### 5.2 性能影響

**基礎搜尋（ILIKE）：**
- 適合數據量：< 10萬筆
- 查詢速度：100-500ms（有索引）
- 資源消耗：低

**全文搜尋（FTS）：**
- 適合數據量：10萬 - 100萬筆
- 查詢速度：50-200ms
- 資源消耗：中等

**專業搜尋引擎：**
- 適合數據量：> 100萬筆
- 查詢速度：< 50ms
- 資源消耗：高（需要額外服務器）

### 5.3 用戶價值

**高優先級功能（必須）：**
- 文章標題搜尋：⭐⭐⭐⭐⭐
- 用戶名搜尋：⭐⭐⭐⭐

**中優先級功能（重要）：**
- 文章內容搜尋：⭐⭐⭐⭐
- 高級過濾：⭐⭐⭐
- 搜尋歷史：⭐⭐⭐

**低優先級功能（加分項）：**
- 即時建議：⭐⭐
- 拼音搜尋：⭐⭐
- 標籤搜尋：⭐⭐

---

## 6. 風險評估

### 6.1 技術風險

| 風險項目 | 風險等級 | 緩解措施 |
|---------|---------|---------|
| 搜尋性能下降 | 🟡 中 | 添加索引、分頁、緩存 |
| 中文分詞效果差 | 🟡 中 | 使用專業分詞器（jieba） |
| 數據庫負載增加 | 🟢 低 | 讀寫分離、查詢優化 |
| 搜尋結果不準確 | 🟡 中 | 調整權重、添加相關性排序 |

### 6.2 產品風險

| 風險項目 | 風險等級 | 緩解措施 |
|---------|---------|---------|
| 用戶不使用搜尋 | 🟡 中 | 數據追蹤、優化 UI/UX |
| 搜尋濫用（spam） | 🟢 低 | 限流、驗證碼 |
| 隱私問題 | 🟢 低 | 搜尋歷史可清除、隱私設置 |

---

## 7. 建議的實現路徑

### 7.1 推薦方案（適合當前階段）

```
開始 → 階段一（基礎搜尋）→ 收集數據和反饋 → 評估 → 
      ↓
      階段二（增強搜尋）或 保持現狀
```

**理由：**
1. 當前平台數據量不大，基礎搜尋足夠
2. 實現快速，可以快速驗證需求
3. 成本低，風險可控
4. 為未來升級預留空間

### 7.2 不建議的做法

❌ **直接上專業搜尋引擎**
- 過度工程化
- 維護成本高
- 當前數據量不需要

❌ **同時開發多種搜尋**
- 分散精力
- 測試複雜
- 效果不一定更好

---

## 8. 實施檢查清單

### 8.1 開發前準備
- [ ] 確認當前數據庫表結構
- [ ] 評估當前數據量
- [ ] 定義搜尋需求優先級
- [ ] 選擇技術方案
- [ ] 設計 API 接口

### 8.2 後端開發
- [ ] 創建 SearchModule、SearchController、SearchService
- [ ] 實現文章搜尋 API
- [ ] 實現用戶搜尋 API
- [ ] 添加分頁和排序
- [ ] 添加數據庫索引
- [ ] 編寫 API 測試
- [ ] 性能測試和優化

### 8.3 前端開發
- [ ] 創建搜尋頁面 UI
- [ ] 實現搜尋服務層
- [ ] 添加搜尋輸入組件
- [ ] 實現結果列表
- [ ] 添加過濾和排序 UI
- [ ] 處理加載和錯誤狀態
- [ ] 優化搜尋體驗（防抖、緩存）

### 8.4 測試驗證
- [ ] 單元測試
- [ ] 集成測試
- [ ] 性能測試
- [ ] 用戶體驗測試
- [ ] 邊界情況測試

### 8.5 上線準備
- [ ] 文檔更新
- [ ] API 文檔
- [ ] 用戶指南
- [ ] 監控和日誌
- [ ] 回滾方案

---

## 9. 總結與建議

### 9.1 核心建議

🎯 **建議先實現階段一：基礎搜尋**

**原因：**
1. **成本效益高**：2-3 天開發時間，滿足 80% 用戶需求
2. **風險可控**：技術簡單，不會影響現有系統
3. **快速驗證**：可以快速上線收集真實用戶反饋
4. **易於迭代**：為未來升級預留了空間

### 9.2 實施時機

**建議在以下情況後再實施：**
- ✅ 核心功能（發文、評論、點讚）已穩定
- ✅ 用戶量達到一定規模（> 100 活躍用戶）
- ✅ 內容量達到一定規模（> 1000 篇文章）
- ✅ 用戶明確表達搜尋需求

### 9.3 關鍵成功因素

1. **簡單開始**：從基礎功能做起，不要過度設計
2. **數據驅動**：追蹤搜尋數據，了解用戶真實需求
3. **持續優化**：根據反饋逐步改進
4. **性能監控**：確保搜尋不影響整體性能
5. **用戶體驗**：搜尋要快、準、易用

### 9.4 長期規劃

```
現在（MVP） → 基礎搜尋 → 數據累積 → 需求明確 → 
               ↓
            增強搜尋 → 數據量增長 → 性能瓶頸 → 
               ↓
            專業搜尋引擎
```

---

## 10. 附錄

### 10.1 參考資源

**PostgreSQL 全文搜尋：**
- [官方文檔](https://www.postgresql.org/docs/current/textsearch.html)
- [Prisma Full-Text Search](https://www.prisma.io/docs/concepts/components/prisma-client/full-text-search)

**搜尋引擎：**
- [Meilisearch](https://www.meilisearch.com/)
- [Elasticsearch](https://www.elastic.co/)
- [Typesense](https://typesense.org/)

**中文分詞：**
- [jieba](https://github.com/fxsjy/jieba)
- [PostgreSQL zhparser](https://github.com/amutu/zhparser)

### 10.2 相關問題

**Q1：搜尋會影響系統性能嗎？**
A：適當的索引和分頁設計下，影響很小。建議在低峰期測試。

**Q2：需要即時搜尋（搜尋建議）嗎？**
A：階段一不建議，會增加複雜度。可在階段二考慮。

**Q3：如何處理中文搜尋？**
A：基礎 ILIKE 對中文效果一般，全文搜尋需要配置中文分詞器。

**Q4：搜尋歷史存在哪裡？**
A：建議前端 LocalStorage，或後端數據庫（需要新表）。

**Q5：要不要搜尋敏感詞過濾？**
A：建議階段一不做，階段二可以加入內容審核。

---

**文檔版本：** v1.0  
**創建日期：** 2025-10-29  
**作者：** HAPPY SHARE 開發團隊  
**狀態：** 📋 規劃中
